## 1. 概述
 
很多人可能或多或少了解过```nginx```，即使没有使用过```nginx```，但是可能用```Apache```搭建过简单的```web```服务器，用```tomcat```写过一些简单的动态页面，其实这些功能nginx都可以实现。

```nginx```最重要的三个使用场景个人认为是```静态资源服务```、```反向代理服务```和```api服务```。

```web```请求走进服务以后会先经过```nginx```再到应用服务，然后再去访问```redis```或者```mysql```提供基本的数据功能。

这就有个问题，应用服务因为要求开发效率高，所以他的运行效率是很低的，他的```qbs```，```tps```并发都是受限的，所以就需要把很多的应用服务组成集群，向用户提供高可用性。

很多服务构成集群的时候，需要```nginx```具有反向代理的功能，可以把动态请求传导给对应的应用服务。服务集群一定会带来两个需求，动态的扩容和容灾。

反向代理必须具备负载均衡的功能，其次在链路中，```nginx```是处在企业内网的边缘节点，随着网络链路的增长，用户体验到的时延会增加。

把一些所有用户看起来不变的，或者在一段时间内看起来不变的动态内容缓存在```nginx```部分，由```nginx```直接向用户提供访问，用户的时延就会减少很多。

反向代理衍生出另外的功能叫缓存，他能够加速访问，而很多时候在访问像```css```或```js```文件又或者一些小图片是没有必要由应用服务来访问的，他只需要直接由```nginx```提供访问就可以了这就是```nginx```的静态资源功能。

应用服务它本身的性能有很大的问题，数据库服务要比应用服务好的多，原因是数据库他的业务场景比较简单，并发性能和```tps```都要远高于应用服务。由```nginx```直接去访问数据库或者```redis```也是不错的选择。

还可以利用```nginx```强大的并发性能，实现如```web```防火墙的一些业务功能，这就要求```nginx```服务有非常强大的业务处理功能，```openResty```和```nginx```集成了一些工具库来实现此功能。

## 2. 历史背景

全球化和物联网的快速发展，导致接入互联网中的人与设备的数量都在快速的上升，数据的快速爆炸，对硬件性能提出很高的要求。

摩尔定律表明之前服务跑在```1GHZ```的```CPU```上的服务更新到```2GHZ```的```CPU```时服务会有两倍的性能提升。

但是到了本世纪初，摩尔定律在单颗```CPU```的频率上已经失效了，```CPU```开始向着多核方向发展，当服务器现在是跑在```8```核```CPU```上时，一年半以后换到了```16```核的```CPU```，服务的性能通常是不会有一倍的提升的。

这些性能主要损耗在操作系统和大量的软件没有做好服务于多核架构的准备，比如说像```Apache```是低效的，因为他的架构模型里一个进程同一时间，只会处理一个连接，一个请求。只有在这个请求处理完以后才会去处理下一个请求。

它实际上在使用操作系统的进程间切换的特性，因为操作系统微观上是有限的```CPU```，但是操作系统被设计为同时服务于数百甚至上千的进程。

```Apache```一个进程只能服务于一个连接，这种模式会导致当```Apache```需要面对几十万，几百万连接的时候，他没有办法去开几百万的进程，而进程间切换的代价成本又太高啦。

当并发的连接数越多，这种无谓的进程间切换引发的性能消耗又会越大。

```nginx```是专门为了这种应用场景而生的，可以处理数百万甚至上千万的并发连接，```nginx```目前在```web```市场份额中排行第二，在过去几年他增长极度迅速，在不久的将来```nginx```在```web```端的应用将远远超过其他服务器。

## 3. nginx的优点

大部分的程序和服务器随着并发连接数的上升他的```RPS```数会急剧的下降，这里的原理就像之前所说过的，他的设计架构是有问题的。

```nginx```的第一个优点就是高并发和高性能同时具备的，往往高并发只需要对每一个连接所使用的内存尽量的少就可以达到。

而具有高并发的同时达到高性能，往往需要非常好的设计，那```nginx```可以达到什么样的标准呢？

比如说现在主流的一些服务器```32```核```64G```的内存可以轻松达到数千万的并发链接，如果是处理一些简单的静态资源请求，可以达到一百万的```RPS```这种级别。

其次```nginx```的可扩展性非常好，主要在于他的模块化设计非常的稳定，而且```nginx```的第三方模块的生态圈非常的丰富。甚至于有像```TNG```,```openRestry```这种第三方插件。丰富的生态圈为```nginx```丰富的功能提供了保证。

第三个优点是它的高可靠性，所谓的高可靠性是指```nginx```可以在服务器上持续不间断的运行数年，而很多```web```服务器往往运行几周或者几个月就需要做一次重启。

对于```nginx```这种高并发高性能的反向代理服务器而言，他往往运行在企业内网的边缘节点上，如果企业想提供```4个9```，```5个9```，甚至更高的高可用性时，对于```nginx```持续运行能够```down```机的时间一年可能只能以秒来计。所以在这种角色中，```nginx```的高可靠性给提供了非常好的保证。

第四个优点热部署，是指可以在不停止服务的情况下升级```nginx```，这对于```nginx```来说非常的重要，因为在```nginx```可能跑了数百万的并发连接。

如果是普通的服务可能只需```kill```掉进程再重启的方式就可以处理好，但是对于```nginx```而言，因为```kill```掉```nginx```进程，会导致操作系统为所有的已经建立连接的客户端发送一个```tcp```中的```reset```报文。而很多客户端是没有办法很好的处理请求的。

在大并发场景下，一些偶然事件就会导致必然的恶性结果，所以热部署是非常有必要的。

第五个优点是```BSD```许可证，```BSD Listens```是指```nginx```不仅是开源的免费的，而且可以在有定制需要的场景下，去修改```nginx```源代码，再运行在商业场景下，这是合法的。

以上的优点是```nginx```最核心的特性。

## 4. 主要组成部分

首先是```nginx```的可执行文件，它是由```nginx```自身的框架、官方模块以及各种第三方模块共同构建的文件。他有完整的系统，所有的功能都由他提供。

第二个部分是```nginx.conf```配置文件，类似于骑车的驾驶员，虽然可执行文件已经提供了许多功能，但这些功能有没有开启，或者开启了以后定义了怎样的行为处理请求，都是由```nginx.conf```配置文件决定的。

```nginx```的第三个组成部分叫做```access.log```访问日志，```access.log```会记录下每一条```nginx```处理过的```http```请求信息与响应信息。

第四个组成部分是```error.log```错误日志，当出现了一些不可预期的问题时，可以通过```error.log```去把问题定位出来。

这四个部分是相辅相成的。

```nginx```的可执行文件和```nginx.conf```定义了处理请求的方式。如果想对web服务，做一些运营或者运维的分析，需要对```access.log```做进一步的分析。如果出现了任何未知的错误，或者与预期的行为不一致时，应该通过```error.log```去定位根本性的问题。

## 5. 版本规则

```nginx```每发布一个版本的时候会有三个特性，一个是```feature```，就是他新增了哪些功能，```bugfix```表示他修复了哪些```bug```，```change```表示做了哪些重构。

每一个版本都有```mainline```主干版本和```stable```稳定版本。

在```nginx```的官网点击右下角的```download```，就可以看到版本号列表，单数版本表示主干版本，会新增很多功能，但不一定稳定。双数版本是稳定版本。

```CHANGES```文件中可以看到每一个版本含有的新增功能，修复的```bug```，以及做了哪些小的重构。

大概在```2009```年以后```nginx```的```bugfix```数量已经大幅度减少，所以```nginx```相对已经很稳定了。

```nginx```的开发时间是在```2002```年，但是他在```2004```年```10```月```4```日推出了第一个版本，在```2005年```曾经做过一次大的重构。

因为```nginx```优秀的设计，使得他的生态圈极为丰富，模块的设计，架构的设计都没有再做过大的变动。

在```2009```年```nginx```开始支持```windows```操作系统，```2011```年```1.0```正式版本发布，同时```nginx```的商业公司```nginx Plus```也成立了，在```2015```年```nginx```发布了几个重要的功能。

其中提供```stream```，```四层反向代理```，他在功能上完全可以替代传统使用的```LVS```, 并且具有更丰富的功能。

## 6. 版本选择

免费开源: ```nginx.org```

商业版本: ```nginx.com```

开源免费的```nginx```在```2002```年开始开发，到```2004```年发布第一个版本，```2011```年开源版的```nginx```发布了```1.0```稳定版，同年```nginx```的作者成立了一家商业公司，开始推出```nginx Plus```商业版的```nginx```。

商业版的```nginx```在整合第三方模块上还有运营监控以及技术支持上有很多优点，但他有个最大的缺点就是不开源，所以通常在国内会使用```nginx.org```开源版的。

阿里巴巴也推出了```Tengine```版本，```Tengine```的优点就是在阿里巴巴生态下他经历了非常严苛的考验，```Tengine```之所以会存在也是因为他的很多特性领先于```nginx```的官方版本。

所以```Tengine```实际上是修改了```nginx```官网版本的主干代码，当然框架被修改以后```Tengine```就遇到了一个明显的问题，没有办法跟着```nginx```的官方版本同步的升级。```Tengine```也可以使用```nginx```的第三方模块。

```OpenResty```的作者章亦春在阿里巴巴的时候开发了```Lua```语言版本的```openResty```，因为```nginx```的第三方模块开发的难度相当大，章亦春把```nginx```非阻塞事件的一种框架以```Lua```语言的方式提供给了广大开发者。

```OenRestry```兼具了高性能，以及开发效率高的特点，```OpenResty```同样有开源版和商业版，目前多使用```openresty.org```站点下的开源版本。商业版```OpenRestry```的主要特点是技术支持相对比较好很多。

如果你没有太多的业务诉求，那么使用开源版的```nginx```就足够了，如果你需要开发```Api```服务器，或者需要开发```web```防火墙，```openrestry```是一个很好的选择。

## 7. 编译配置

安装```nginx```有两种方法，除了编译外，还可以直接用操作系统上自带的一些工具，比如说```yum```，```apt-get```，直接去安装```nginx```。

但是直接安装```nginx```有个问题，就是```nginx```的二进制文件不会把模块直接编译进来，毕竟```nginx```的官方模块，并不是每一个默认都会开启的。

如果想添加第三方的```nginx```模块，就必须通过编译```nginx```的方式。

编译```nginx```主要分为六个部分，首先需要下载```nginx```，从```nginx.org```网站上直接下载就可以。

打开```nginx.org```在页面中找到右下角```donwload```，选择```Stable```版本的下来链接，右键复制链接地址即可，进入到```Linux```中使用```wget```进行下载

```s
cd  /home/nginx
wget http://nginx.org/download/nginx-1.18.0.tar.gz
```

下载完```nginx```压缩包以后首先解压压缩包。

```s
tar -xzf nginx-1.18.0.tar.gz
```

接着进入解压后的目录通过```ll```命令查看所有文件。

```s
cd nginx-1.18.0
ll
```

第一个目录叫```auto```目录。

```s
cd auto
```

```auto```目录里面有四个子目录，```cc```是用于编译的，```lib```库和对操作系统的判断在```os```里面，其他所有的文件都是为了辅助```config```脚本执行的时候判定```nginx```支持哪些模块以及当前的操作系统有什么样的特性可以供给```nginx```使用。

```CHANGES文```件标记了```nginx```每一个版本中提供了哪些特性和```bugfix```。

```s
cat ../CHANGES
```

其中会有```feature```，```bugfix```，```change```三种特性在里面。

```CHANGES.ru```文件是俄罗斯语言的```CHANGES```文件，可能因为作者是个俄罗斯人。

```conf```文件是一个示例文件，就是把```nginx```安装好以后，为了方便运维配置，会把```config```里面的示例文件```copy```到安装目录。

```configure```脚本用来生成中间文件，执行编译前的一个一些配置，也就是记录编译前的设定信息，编译时使用。

```contrib```目录提供了两个脚本和```vim```工具，也就是让```vim```打开```config```配置文件时支持代码高亮。

把```contrib```目录下```vim```的所有文件```copy```到自己的目录中

```s
cp -r contrib/vim/* ~/.vim/
```

就可以把```nginx```语言的语法高亮显示在```vim中```了。

```html```目录里面提供了两个标准的```HTML```文件，一个是发现```500```错误的时候可以重定向到的文件，另一个是默认的```nginx```的欢迎界面```index.html```。

```man```文件里则是```Linux```对```nginx```的帮助文件，里面标识了最基本的```nginx```帮助和配置。

```src```目录是```nginx```的核心源码。

## 8. 开始编译

编译前可以先看一下```configure```支持哪些参数。

```s
./configure --help | more
```

首先就是确定```nginx```执行中会去找哪些目录下的文件作为辅助文件。比如用动态模块时```--modules-path```就会产生作用。```--lock-path```确定```nginx.lock```文件放在哪里等。

如果没有任何变动的话只需要指定```--prefix=PATH```就可以了，设定一个安装目录。

第二类参数主要是用来确定使用哪些模块和不使用哪些模块的，前缀通常是```--with```和```--without```。

比如说-```-with-http_ssl_module```或者```--with-http_v2_module```通常需要主动加```--with```的时候，意味着模块默认是不会编译进```nginx```的。

而模块中显示```--without```比如说```--without-http_charset_module```意味着默认他会编译进```nginx```中，加了参数是把他移除默认的```nginx```的模块中。

第三类参数中指定```nginx```编译需要的一些特殊的参数，比如说用```cc```编译的时候需要加一些什么样的优化参数，或者说要打印```debug```级别的日志(```--with-debug```)以及需要加一些第三方的模块(```--with-zlib-asm=CPU```)

这里指定的```nginx```的安装目录是在```/home/nginx```目录下。

```s
./configure --prefix=/home/nginx/nginx/
```

如果没有任何报错```nginx```就已经编译成功了，所有```nginx```的配置特性以及```nginx```运行时的目录都会列在最下方。

在```config```执行完之后，会看到生成了一些中间文件。中间文件会放在```objs```文件夹下。最重要的是会生成一个文件叫做```ngx_modules.c```他决定了接下来执行编译时哪些模块会被编译进```nginx```。可以打开看一下所有被编译进```nginx```的模块都会列在这里，他们最后会形成一个叫做```ngx_modules```的数组。

执行```make```编译。

```s
make
```

编译完成以后如果没有任何错误，就可以看见生成了大量的中间文件，以及最终的```nginx```二进制文件。

```s
cd objs/
ll
```

最后进行```make install```。

```s
make install
```

安装完成之后在```--prefix```指定的安装目录中可以看到很多目录，```nginx```的执行文件就在```sbin```目录下。

决定```nginx```功能的配置文件在```conf```下，```access.log```和```error.log```在```log```文件夹下。

可以看到在```conf```目录下所有文件就是在源代码中```conf```目录copy过来的，其中的内容也是完全相同的。

## 9. 配置语法

```nginx```可执行文件中已经指定了他包含了哪些模块，但每一个模块都会提供独一无二的配置语法。

这些所有的配置语法，会遵循同样的语法规则。

```nginx```的配置文件是一个```ascii```的文本文件，主要有两部分组成，```指令```和```指令快```。

```s
http {
    include mime.types;
    upstream thwp {
        server 127.0.0.1:8000;
    }

    server {
        listen 443 http2;
        # nginx配置语法
        limit_req_zone $binary_remote_addr zone=one:10 rate=1r/s;
        location ~* \.(gif|jpg|jpeg)$ {
            proxy_cache my_cache;
            expires 3m;
        }
    }
}
```

上面```http```就是一个指令快，```include mime.types;```就是一条指令。

每条指令以分号结尾，指令和参数间以空格分隔。```include mime.types;```中```include```是一个指令名，```mime.types```是参数中间可以用一个或多个空格分隔。参数可以有多个，比如下面的```limit_req_zone```有三个参数，多个参数之间也是用空格分隔。

两条指令间是以```;```作为分隔符的，两条指令放在一行中写也是没有问题的。只不过可读性会变得很差。

第三个指令块是以 ```{}``` 组成的，他会将多条指令组织到一起，比如```upstream```，他把一条指令```server```放在了```thwp```指令块下面。

```server```中也放置了```listen```，```limit_req_zone```这些指令，他也可以包含其他的指令块，比如说```location```。

有些指令可以有名字，比如```upstream```，后面有个```thwp```作为他的名字。

具体什么样的指令有名字什么样的指令没有名字是由提供指令块的```nginx```模块来决定的，他也可以决定指令块后面有一个或者说多个参数，或者说没有参数。

```include```语句允许引入多个配置文件以提升可维护性。在例子```中mime.types```文件中其实里面是含有很多条不同的文件的后缀名与```http```协议中```mime```格式的对照关系表。

```include```是导入其他配置模块的意思。

```#```符号可以添加注释，提升可读性，比如在listen后面加了一个```nginx```配置语法的注释，以描述下面一些配置的表达。

使用```$```符号可以使用变量，可以看下```limit_req_zone```这里用了一个参数叫做```$binary_remote_addr```，这是一个变量描述的是远端的地址。

部分指令的参数是支持正则表达式的，比如```location```后面可以看到，他可以支持非常复杂的正则表达式，而且可以把正则表达式括号里的内容通过```$1```,```$2```,```$3```的方式取出来。

在```nginx```的配置文件中当涉及到时间的时候，还有许多表达方式，比如下面的方式:

```s
ms -> 毫秒
s  -> 秒
m  -> 分钟
h  -> 小时
d  -> 天
w  -> 周
M  -> 月
y  -> 年
```

比如```location```中的```expires 3m;```就表示```3分钟```后希望```cache```刷新。

空间也是有单位的，当后面不加任何后缀名时表示字节```bytes```，加了```k```或者```K```表示千字节，```m```表示兆字节，```g```表示```G```字节。

```http```大括号里面所有的指令都是由```http```模块去解析和执行的，非```http```模块，比如说像```stream```或```mime```是没有办法去解析指令的。

```upstream```表示上游服务，当```nginx```需要与```Tomcat```等企业内网的其它服务交互的时候呢，可以定义一个```upstream```。

```server```对应的一个或一组域名，```location```是```url```表达式。

## 10. 重载，热部署，日志切割

需要帮助的时候可以用```-?``` 或者 ```-h```获取帮助信息。

```s
nginx -?
nginx -h
```

默认情况下编译出来的```nginx```会寻找执行```configure```命令时指定的配置文件。在命令行中可以指定另一个配置文件用``` -c 路径 ```。

还能指定一些配置用```-g```，指令就是在```nginx```的```configure```目录里的指令。

```nginx```操作运行中的进程一般是通过发送信号，可以通过```linux```的```kill```命令也可以用```nginx -s```子命令，子命令后可以用```stop```，```quit```，```reload```，```reopen```。

```s
nginx -s stop # 停止nginx服务
nginx -s quit # 优雅的停止nginx服务
nginx -s reload # 重载配置文件
nginx -s reopen # 重新开始记录日志文件。
```

```-t```可以测试一下配置文件是否合法问题。

```-V```是在编译时用```configure```脚本执行所加的所有参数。

### 1. 重载配置文件

修改````nginx````配置文件中的一些值，比如说```conf/nginx.conf```文件中，打开```tcp_nopush```。

当修改完配置文件以后，可以直接执行```nginx -s reload```命令```nginx```是在不停止对客户服务的情况下使用了```tcp_nopush```新的配置项，非常的简单。

### 2. 热部署

```nginx```在运行的情况下想更换最新版本的```nginx```，根据之前所说的，```nginx```编译方法下载一个新的```nginx```。

把最新版本的```nginx```编译后的可执行文件```nginx```，```copy```到目录中替换掉正在运行的```nginx```文件。```copy```完成需要给正在运行的```nginx```的```master```进程发送一个信号，告诉他开始进行热部署做一次版本升级，给```nginx```的```master```进程发送一个信号，```USR2```信号。

```s
kill -USR2 进程号(13195)
```

```nginx```会新启一个```master```进程使用的正式刚刚复制过来的最新的```nginx```二进制文件。

旧的```worker```也在运行，新的master会生成新的```worker```，他们会平滑的把所有的请求过渡到新的进程中。

新的请求新的连接会进入新的```nginx```进程中，这时需要向老的```nginx```进程发送一个信号叫做```WINCH```，告诉他优雅的关闭所有进程。

```s
kill -WINCH 13195
```

这时老的```worker```进程会优雅的退出，但是老的```master```进程还在，只是是没有```worker```进程了。

这说明所有的请求已经全部切换到新的```nginx```中了，如果需要把新版本退回到老版本，可以向老的进程发送```reload```命令，让他重新把```worker```进程拉起来。再把新版本关掉。所以保留```master```是为了允许做版本回退。

### 3. 日志切割

比如说当前的日志已经很大了。需要把以前的日志备份到另外一个文件中，但是```nginx```还是正常运行的。

这就要通过```reopen```命令来做，首先需要把当前正在使用的日志```copy```一份放在另外的位置.

```s
mv access_log bak.log
```

接着执行命令```reopen```。

```s
nginx -s reopen
```

就重新生成了一个```access.log```, 原本的```log```备份成了```bak.log```,就实现了日志切割。

当然这种方法会非常不好用，实际上往往是每一天，或者是每一周执行一次日至切割，可以先写成一个```bash```脚本。

在```bash```脚本中首先把文件复制一下，再执行-```s reopen```命令，最后把脚本放在```crontab```中。

## 11. 静态资源Web服务器

编辑```conf/nginx.conf```文件找到```server```代码块中，```listen```配置监听端```8080```端口，然后需要配置一个```location```，使用```/```让所有的请求都访问到```www```文件夹。

这里需要指定```url```的后缀与文件的后缀一一对应，有两种用法，```root```和```alias```，```root```是系统的跟目录，所以通常使用```alias```，```alias```是```nginx```的安装目录。

```s
server {
    listen 8080;
    ...
    location / {
        alias www/;
        ...
    }
    ...
}
```

做完配置之后启动```nginx```在浏览器中访问```localhost:8080```就可以了。

```s
nginx -s reload
```

### 1. 开启gzip

做完```gzip```压缩传输的字节数会大幅度减少，所以通常会打开```gzip```。

首先打开```nginx.conf```文件，找到```http```代码块中的```gzip```相关选项，打开```gzip(off -> on)```, ```gzip_min_length```是小于多少字节不再执行压缩，因为小于一定的字节```http```传输直接就可以发送了，压缩反而消耗```cpu```性能，```gzip_comp_level```代表压缩级别，```gzip_types```是针对某些类型的文件才做```gzip```压缩。

```s
http {
    ...
    gzip on;
    gzip_min_length 1;
    gzip_comp_level 2;
    gzip_types text/plain applicaton/x-javascript text/css image/png;
    ...
}
```

配置好后重启```nginx```, 浏览器中查看就会发现，传输的文件已经减少了很多，响应头中多出了```Content-encoding: gzip```。使用```gzip```以后整个```web```服务传输效率会高很多。

### 2. 打开目录结构

```nginx```给提供了一个官方模块叫做```autoindex```，他可以提供当访问以```/```结尾的```url```时，显示目录的结构。使用方法也特别简单，就是```autoindex on```加入一个指令就可以了。

```s
location / {
    autoindex on;
}
```

他会把所访问的文件夹内所有文件列出来，当打开一个目录时，可以继续显示目录中的文件，这是一个很好的静态资源帮助功能。

### 3. 网速限制

比如公网带宽是有限的，当有很多并发用户使用带宽时，他们会形成一个争抢关系，可以让用户访问某些大文件的时候来限制他的速度，节省足够的带宽给用户访问一些必要的小文件。

就可以使用```set```命令，配合一些内置的变量实现这种功能，比如说加上```set $limit_rate 1k```，限制```nginx```向客户浏览器发送响应的一个速度。意思是每秒传输多少数据到浏览器中。

```s
location / {
    set $limit_rate 1k;
}
```

### 4. 日志

首先需要设置```access```日志格式，找到一个指令叫做```log_format```, 他用来定义日志的格式，这里可以使用变量。

```s
http {
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
    '$status $body_bytes_sent "$http_referer" '
    '"$http_user_agent" "$http_x_forwarded_for"';
}
```

```$remote_addr```为远端的地址，也就是浏览器客户端的```ip```地址，```$time_local```表示当时的时间。```$status```是返回的状态码。格式定义好之后需要定义一个名字，这里是```main```。

不同的名字可以对不同的域名下，做不同格式的日志记录，或者对不同的```url```记录不同日志格式。

配置好```log_format```之后，就可以用```access_log```指令，配置日志了。```access_log```所在的代码块决定了日志的位置比如```access_log```这里放在了```server```下，也就是所有请求这个路径和端口的请求日志，都会记录到```logs/yindong.log```文件中，使用的格式就是```main```。

```s
server {
    listen 8080;
    access_log logs/yindong.log main;
    location / {
        alias dlib;
    }
}
```

配置好```yindong.log```后，所有的请求在完成之后都会记录下一条日志，可以进入logs/yindong.log中查看每一条都是设置的格式。

## 12. 反向代理服务

由于上游服务要处理非常复杂的业务逻辑而且强调开发效率，所以他的性能并不怎么样，使用```nginx```作为反向代理以后，可以由一台```nginx```把请求按照负载均衡算法代理分配给多台上游服务器工作。

这就实现了水平扩展的可能，在用户无感知的情况下，添加更多的上游服务器，来提升处理性能，而当上游服务器出现问题的时候，```nginx```可以自动的把请求从有问题的服务器，转交给正常的服务器。

反向代理需要添加一个```upstream```，就是上游服务```server```，访问地址是```127.0.0.1:8080```如果有很多台上游服务可以依次的放在这里。

```upstream```设置的一批服务叫```local```。对所有的请求使用```proxy_pass```一条指令，代理到local里。

```s
upstream local{
    server 127.0.0.1:8080;
}
server {
    server_name yindong.com;
    listen 80;
    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # 反向代理转发
        proxy_pass http://local;
    }
}
```

因为反向代理的原因，真实的服务器拿到的信息是经过```nginx```代理服务器转发的，所以很多信息都不是真实的，比如说```域名```，```ip```都是代理服务器发送过来的，所以需要在```location```中做一些配置处理。

通过```proxy_set_header```可以把有一些值添加一条新的```header```发送到上游，比如说叫```x-real-ip```，然后把他的值设为从```tcp```链接里面拿到的远端```ip```地址。

```$host```也是同样的因为用户直接访问的域名，是他在浏览器输入的，既可以让他在上游服务器可以处理域名，也可以由反向代理来处理。


所有这些配置特性都可以在官网中的```http_proxy_module```找到。

### 1. 缓存

这里有个很重要的特性```proxy_cache```, 因为当```nginx```作为反向代理时，通常只有动态的请求，也就是不同的用户访问同一个```url```看到的内容是不同的，才会交由上游服务处理。

但是有一些内容可能是一段时间不会发生变化的，为了减轻上游服务器的压力，就会让```nginx```把上游服务返回的内容缓存一段时间，比如缓存一天，在一天之内即使上游服务器对内容的响应发生了变化，也不管，只会去拿缓存住的这段内容向浏览器做出响应。

因为```nginx```的性能远远领先于上游服务器的性能。所以使用一个特性后，对一些小的站点会有非常大的性能提升。

配置缓存服务器首先要去通过```proxy_cache_path```这条指令去设置缓存文件写在哪个目录下。

比如这里是```/tmp/nginxcache```, 以及这些文件的命名方式，这些文件的关键词```key```,要放在共享内存中的。这里开了```10MB```的共享内存，命名为```my_cache```。

```s
proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path_off;
```

缓存的使用方法就是在需要做缓存的```url```路径下，添加```proxy_cache```, 后面所跟的参数就是刚刚开辟的那个共享内存，在共享内存中所设置的```key```就是同一个```url```访问时对不同的用户可能展示的东西是不一样的，所以用户这个变量就要放在```key```中。

这里做一个非常简单的```key```，比如说访问的```host url```可能加了一些参数，这些参数可能已经指明了是哪个用户哪个资源，```$host$uri$is_args$args;``` 这些作为一个整体的```key```。

```s
location / {
    proxy_cache my_cache;
    proxy_cache_key $host$uri$is_args$args;
    proxy_cache_valid 200 304 302 1d;
}
```

加完这些参数以后，可以尝试停掉上游服务，然后访问站点，可以发现站点仍然是可以访问的。就是因为被缓存了。

## 13. 监控access日志

```Access```日志记录了```nginx```非常重要的信息，可以用日志来分析定位问题，也可以用它来分析用户的运营数据，但是如果想实时分析```Access.log```相对来说还比较困难。

有一款工具叫```GoAccess```可以以图形化的方式，通过```websocket```协议实时的把```Access.log```的变迁反应到浏览器中，方便分析问题。

```GoAccess```的站点是 ```https://goaccess.io```, 以一种非常友好的图形化方式显示。

```GoAccess```使用```-o```参数生成新的```html```文件，把当前```access.log```文件中的内容以html图表的方式展示出来，当```access.log```变迁的时候```GoAccess```会新起一个socket进程，通过端口的方式把新的```access.log```推送到客户端。

```s
goaccess access.log -o report.html --log-format=COMBINED
```

首先制定```access.log```程序制定的位置(```yindong.log```), 把它输出到```../html/report.html```文件中，使用的是```--real-time-html```就是实时更新页面的方式，时间格式```--time-format='%H:%M:%S'```, 日期格式```--date-format='%d/%b/%Y'```, 以及日志格式```--log-format=COMBINED```。

```s
cd logs
goaccess yindong.log -o ../html/report.html --real-time-html --time-format='%H:%M:%S' --date-format='%d/%b/%Y' --log-format=COMBINED
```

```GoAccess```的安装可以用```yum```或者```wget```，也可以下载源码进行编译。

启动完成之后可以看到一条```log```叫做``` WebSocket server ready to accept new client connections```, 也就是他已经打开了一个新的```websocket```监口，当访问```report.html```的时候，会向进程发起连接, 由进程给推送最新的```log```变更。

接下来还要在```nginx.conf```中添加```location```，当访问```/report.html```时候用```alias```重定向到```report.html```。

```s
server {
    ...
    location /report.html {
        alias /usr/local/openresty/nginx/html/report.html;
    }
    ...
}
```

打开```localhost:8080/report.html```就可以看到效果了。

使用```GoAccess.log```可以非常直观的看到```access.lo```g统计信息上的变迁，对分析网站的运营情况非常有帮助，可以看到每个时间点，每一周每一天，甚至不同的国家地区使用不同浏览器和操作系统的人使用站点的一个比例和分布。

## 14. SSL安全协议

```SSL```的全称是``Secure Sockets Layer``，现在很多时候使用的是```TLS```也就是```Transport Layer Security```。可以将```TLS```看做是```SSL```的升级版。

```SSL```是网景公司在```1995```年推出的，后来因为微软把自己的```IE浏览器```捆绑```windows```一起卖出导致网景遇到很大的发展困境，网景把```SSL```协议交给```IETF```组织。

在```1999```年，应微软的要求```IETF```把```SSL```更名为```TLS1.0```，在```06```，```08```到```2018```年``TLS``分别发布了```1.1```，```1.2```和```1.3```协议。

那么```TLS```协议究竟是怎样保证```http```的明文消息被加密的呢？

在```ISO/OSI```七层模型中，应用层是```http```协议，在应用层之下，表示层也就是```TLS```所发挥作用的这一层，通过```握手```，```交换密钥```，```告警```，```对称加密```的方式使```http```层没有感知的情况下做到了数据的安全加密。

当抓包或者观察服务端配置时，可以看到安全密码的配置，安全密码的配置决定了```TLS```协议是怎样保证明文被加密的。这里大概有四个组成部分。

第一个组成部分叫做密钥交换，也就是```ECDHE```，这实际上是一个椭圆曲线加密算法的表达，密钥交换是为了让浏览器和服务器之间怎样各自独立的生成密钥，数据传输时他们会用密钥去加密数据。加解密是需要使用到对方的密钥的所以需要进行交换。

在密钥交换过程中，需要让浏览器和服务器各自去验证对方的身份，而验证身份是需要一个算法的，叫做```RSA```。

进行数据加密，解密这种通讯的时候，需要用到对称加密算法```AES_128——GCM```，其中第一个部分```AES```表达了是怎样一种算法，```128```表示了```AES```算法里支持了```3```种加密强度，使用```128```位这种一个加密强度。```AES```中有很多分组模式```GCM```是一种比较新的分组模式，可以提高多核```CPU```情况下加密和解密的一个性能。

```SHA_256```是摘要算法，他用来把不定长度的字符串生成固定长度的更短的摘要。

## 15. 对称加密、非对称加密

在对称加密场景中，两个想通讯的人张三和李四，他们共同持有同一把密钥，张三可以把原始明文的文档，通过这一把密钥加密生成一个密文文档，而李四拿到文档以后呢，他可以用这把密钥还原转换为原始的明文文档，而中间的任何人如果没有持有这把密钥，即使他知道了对称加密的算法他也没有办法把密文还原成原始文档。

那么对称加密究竟的实现可以以```RC4```对称加密的序列算法来描述。

使用异或(```xor```)操作, 他是一个位操作，比如```1```和```0```进行异或得到```1```，```0```和```1```也得到了```1```，那么相同的```1```和```1```或者```0```和```0```进行异或操作都会得到```0```。

在一个场景下```1010```是共同持有的密钥，```0110```是明文，张三执行加密的时候就会得到密文```1100```。

```s
1 0 1 0 # 密钥
  xor   # 异或操作
0 1 1 0 # 明文
  | |    # 输出
1 1 0 0 # 密文
```

异或有一个对称的特性，就是把密文与密钥同样的做异或操作可以得到明文。

```s
1 0 1 0 # 密钥
  xor   # 异或操作
1 1 0 0 # 密文
  | |    # 输出
0 1 1 0 # 明文
```

密文可以用同一把密钥完全还原成了明文，所以对称加密有一个最大的优点就是他的性能非常的好，他只要遍历一次就可以得到最终的密文，解密的过程也是一样，而非对称加密他的性能就会差很多。

非对称加密根据一个数学原理，他会生成一对密钥，这一对密钥中如果称其中一个叫做公开钥匙(```公钥```)，那么另一个就叫做私有钥匙(```私钥```)。

公钥和私钥作用就是同一份命名文档如果用公钥加密了那么只有用对应的私钥才能把它解密，同样道理，如果文档用私钥加密了用公钥才能解密。

比如说李四他有一对公钥和私钥，那么他就可以把他的公钥发布给大家，比如张三是其中的一个人，他拿到了李四的公钥，加密操作是怎么做的呢？

张三如果想传递一份原始文档给李四，那么张三就可以拿着李四的公钥对原始文档进行加密，把密文再发送给李四，李四用自己的私钥才能进行解密，其他人即使得到了这份文档也没有办法进行解密。

```s
 ----------                ----------                  ----------  
|  ------  |  李四的公钥    |  ------  |   李四的私钥     |  ------ | 
|  ------  | -----------> |  -- 密 -- |  ----------->  |  ------ |
|  ------  |    加密       |  ------  |     解密        |  ------ |
 ----------                ----------                  ----------
   原始文档                    加密文档                     原始文档 
```

公钥和私钥还有第二种用途，就是身份验证，比如现在有一段信息李四用它的私钥进行了加密，然后把密文发给了张三，只要张三如果可以使用李四的公钥解开这份文档，那么就证明这段密文确实是由李四发出的。因为只有李四有自己的加密私钥，如果是王五加密的文档张三用李四的公钥是解不开的，只有用李四私钥加密的使用李四的公钥才能解开。

## 16. SSL证书的公信力

这里其实还有个问题，李四怎么就知道消息真的是张三发过来的。这里面涉及到一个新的概念叫公信机构。在多方通信的过程中必须有一个公信机构CA，负责颁发证书和把证书过期的。

作为站点的维护者就是证书的订阅人，首先必须申请一个证书，申请证书可能需要登记是谁，属于什么组织，想做什么。

登记机构通过```CSR```发给```CA```，```CA```中心通过后会生成一对公钥和私钥，公钥在```CA```保存着，公钥私钥证书订阅人拿到之后就会把它部署到自己的```web```服务器，当浏览器访问站点的时候，服务器会把公钥证书发给浏览器，浏览器需要向```CA```验证证书是否合法和有效的。如果有效就证明没有被篡改。

由于```CA```会把过期的证书放在```CRL```服务器里，服务器会把所有过期的证书形成一条链条所以他的性能非常的差，后来又推出了```OCSP```程序可以就一个证书去查询是否过期，所以浏览器是可以直接去查询```OCSP```响应程序的，但```OCSP```响应程序性能还不是很高。

nginx会有一个```OCSP```的开关，当打开开关以后会由```nginx```主动的去```OCSP```去查询，大量的客户端直接从```nginx```就可以获取到证书是否有效。

证书一共有```3```种类型。

第一种叫做域名验证```DV```证书，也就是说证书只会去验证域名的归属是否正确，申请证书的时候只要域名指向的服务器是正在申请证书的服务器，就可以成功的申请到证书。

第二种证书叫做组织验证```OV```证书，组织验证就是在申请证书的时候会去验证填写的机构，企业名称是否是正确的，申请```OV```证书往往需要几天的时间，不像```DV```证书，基本上实时就可以获取到，```OV```证书的价格远远高于```DV```证书，```DV```证书很多都是免费的。

比```OV```证书做更严格的是```EV```证书，大部分浏览器对```EV```证书显示的非常友好，他会把证书申请时所填写的机构名称在浏览器的地址栏中显示出来。

浏览器在安全角度对```DV```，```OV```,，```EV```证书他的效果是一样的。唯一验证的就是证书链。

如果你点击网站地址栏中的锁头标志，打开证书链的时候，可以发现存在三个级别，目前所有主证书都是由根证书、二级证书、主证书三个证书构成的。

之所以需要三级机构是因为根证书的验证是非常谨慎的，如```windows```，安卓等操作系统每一年以上才会去更新一次根证书库，所以一个新的根证书```CA```机构是很难快速的加入到操作系统或者浏览器中的。

大部分浏览器他使用的是操作系统的证书库，只有像```firefox```这种浏览器会维护自己的根证书库，所以浏览器在验证证书是否有效时，除了验证有没有过期以外，最主要就是在验证根证书是不是有效的，是不是被跟证书库所认可的。

```nginx```在向浏览器发送证书的时候需要发送两个证书，根证书是被操作系统或者浏览器内置的并不需要发送。首先发送站点的主证书，接着会发送二级证书，浏览器会自动去认证二级证书的签发机构，根证书是不是有效的。

浏览器和服务器之间通信时确认对方是信赖的人其实就是验证给站点颁发根证书的发行者是不是有效的。

## 17. SSL协议握手时nginx的性能瓶颈

TLS的通信过程主要想完成四个目的。

### 1. 验证对方身份

浏览器会向服务器发送一个```client hello```消息。有一浏览器非常多样化，而且版本在不停的变更。所以不同的浏览器所支持的安全套件，加密算法都是不同的。这一步主要是告诉服务器，浏览器支持哪些加密算法。

### 2. 对安全套件达成共识

```nginx```有自己能够支持的加密算法列表，以及他倾向于使用的哪一个加密算法套件，```nginx```会选择一套他最喜欢的加密套件发送给客户端。

如果想复用```session```，也就是说```nginx```打开了```session cache```，希望在一天内断开链接的客户端不用再次协商密钥，可以直接去复用之前的密钥。

```server hello```信息中主要会发送究竟选择哪一个安全套件。

### 3. 传递并生成密钥

```nginx```会把自己的公钥证书发送给浏览器，公钥证书中包含证书链，浏览器可以找到自己的根证书库，去验证证书是否是有效。

### 4. 对数据进行加密通讯

服务器会发送```server hello done```，如果之前协商的安全套件是椭圆曲线算法，这时会把椭圆曲线的参数发送给客户端。客户端需要根据椭圆曲线的公共参数，生成自己的私钥后再把公钥发送给服务器。

服务器有了自己的私钥，会把公钥发送给客户端，服务端可以根据自己的私钥和客户端的私钥，共同生成双方加密的密钥。

客户端根据服务器发来的公钥和他自己的私钥也可以生成一个密钥。

服务器和客户端各自生成的密钥是相同的，是由非对称加密算法保证的。接着可以用生成的密钥进行数据加密，进行通信。

```TLS```通信主要在做两件事，第一个是交换密钥，第二个是加密数据，主要的性能消耗也是这两点。

nginx在这里是有性能优化的，主要是他的算法性能，对于小文件，握手是影响```QPS```性能的主要指标，对于大文件而言，主要考虑对称加密算法的性能比如```AES```，对称加密算法虽然性能很好，但是对非常大的一个文件，测吞吐量时还是```AES```的性能比较好的。

当以小文件为主时主要考验的是```nginx```的非对称加密的性能，比如说```RSA```，当主要处理大文件时主要考验的是对称加密算法的性能，比如说```AES```。

面对的场景是小文件比较多时重点应该优化椭圆曲线算法的一些密码强度，看是不是有所降低，当主要面对大的文件处理的时候需要考虑```AES```算法是不是可以替换为更有效的算法，或者把密码强度调得更小一些。

## 18. 用免费SSL证书实现一个HTTPS站点

首先需要有一个域名比如说````yindong.zhiqianduan.com````他是一个```http```的网址。

接着开始安装工具，必须的工具。

如果系统是```CentOS```，可以使用```yum```安装，优班图系统可以使用```wget```工具下载。

```s
yum install pthon2-certbot-nginx
```

安装好会提供```certbot```命令，当后缀加上```--nginx```的时候就开始为```nginx```的```conf```自动执行相应的修改。通常他会默认修改```/usr/local/```目录下的```nginx```配置。可以通过```--nginx-server-root```指定```nginx.conf```所在的路径。

使用```-d```指定需要申请证书的域名，比如说```yindong.zhiqianduan.com```。

```s
certbot --nginx --nginx-server-root=/usr/local/nginx/conf/ -d yindong.zhiqianduan.com
```

首先他会去获取一个证书，接着会等待验证，然后把证书部署到```nginx.conf```文件中。最后提示两个选择，第一不要做任何的重定向，第二做重定向。重定向就是将```http```的访问```302```到```https```从而禁掉不安全的```http```访问。

选择之后就可以使用```https```访问```yindong.zhiqianduan.com```域名了。```https://yindong.zhiqianduan.com```

他是在在```server```指令块中增加了```443```端口，让后将公钥证书和私钥证书部署好，并把一些通用的参数通过```include```加入到配置文件中。

因为```ssl```中最消耗性能是的握手，所以为了降低握手增加了```sessin_cache```, 设置```1m```，可以为大约```4000```个链接建立服务。也就是说每个```http```链接握手建立第一次以后如果断开了再次链接，那么在````session_timeout````时间以内是不用进行再次握手的。可以复用之前的密钥，```session_timeout```设置了```1440m```，也就是一天。

```ssl_protocols```表示```https```支持哪些版本的```TLS```协议，```ssl_prefer_server_ciphers```表示```nginx```开始决定使用哪些协议与浏览器进行通信，他是通过```ssl_ciphers```中的安全套件，所有的安全套件以分号分隔，是有顺序的，排在前面的会优先被使用。

最后```server```中的```ssl_dhparam```是表示加密的时候使用怎样的参数，这些参数会决定网络安全的加密强度。

## 19. 基于OpenResty用Lua语言实现简单服务

在```openresty```的站点(openresty.org)下载，在源码发布中找到最新版本，复制他的下载链接进行下载。

```s
wget http://openresty.org/download/openresty-1.13.6.2.tar.gz
```

下载完成以后解压压缩包，然后进入到源代码目录，可以发现```openresty```目录和```nginx```的源代码目录相比少了很多东西，少的这些东西都在```bundle```目录下，```build```目录是编译以后生成的一些中间目标文件。

在```bundle```目录中有很多模块，最核心的是```nginx```的源代码，也就说当前的```OpenResty```是基于对应的```nginx```版本进行的二次开发。

所有```nginx```对应版本中没有的特性都不可能出现在```OpenResty```的版本中。

其他的目录又分为两类，第一类是```nginx```的第三方模块，都是一些```C```模块，通常会以```ngx```开头。第二类模块是```LUA```模块，是```lua```代码写就的，他需要使用刚刚那些```C```模块提供的各种功能，在编译的时候主要是在编译```C```模块。

```s
./configure --help | more
```

通过帮助文件可以看到```OpenResty```和```nginx```基本没有太大的不同，只不过```OpenResty```他集成了很多第三方模块，比如```http_echo```, ```http_xss```等等，这些在```nginx```的官方版本中是没有的。这些模块很多是```OpenResty```的作者写的。

最核心的```lua_module```核心模块通常是不能移除来的，移除来之后整个```lua```就不能运行了。其他的配置项和官方的```nginx```基本上是一样的。

```s
./configure

make install
```

要将```lua```代码添加到```OpenResty```当中首先打开```OpenResty```的```conf```文件，在文件中是可以直接添加```lua```代码的，但是不能直接的把```lua```的语法放在```conf```中，因为```nginx```的解析器配置语法和```lua```代码是不相同的。

在```OpenResty```的```nginx_lua_module```中提供了几条指令，其中有一条叫做```content_by_lua```, 是在```http```请求处理的内容生成阶段用```lua```代码来处理。

增加一个```location```，当输入```/lua```的时候，使用```lua```代码进行处理, 为了使输出的文本能够以浏览器直接显示文本的方式显示，添加一个```default_type text/html```，在```content_by_lua```中加一些最简单的命令来演示lua是怎么生效的。

在```OpenResty```的```lua```模块中提供了一些```API```，比如说```ngx.say```会生成```http```响应，他是放在```http```请求的```body```中的，并不是放在```header```中的。

可以通过```ngx.say```语法将内容添加到```body```中的文本中。这里通过```ngx.req.get_headers```把用户请求时的```http```头取出来，然后找出```UA```，把值返回给浏览器。

```s

server {
    server_name yindong.com;
    listen 80;

    location /lua {
        default_type text/html;
        content_by_lua 'ngx.say("User-Agent: ", ngx.req.get_headers()["User-Agent"])';
    }

    location / {
        alias html/yindong/;
    }
}
```

访问```/lua```就可以看到效果了。

通过```OpenResty```的```nginx_lua_http```模块可以用它提供的```API```完成很多功能，可以用```lua```语言本身的一些工具库，把```lua```语言添加进来参与响应的过程。

可以用```lua```语言以及相应的提供的工具库直接访问```redis```，```mysql```或者```tomcat```等服务，然后把不同的响应通过程序逻辑组合成相应的内容返回给用户。
