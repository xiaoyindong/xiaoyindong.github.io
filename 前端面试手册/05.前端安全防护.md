## XSS

英文是```Cross Site Scripting```跨站脚本攻击，因为缩写和```CSS```重叠，所以只能叫```XSS```，是指通过存在安全漏洞的```Web```网站注册用户的浏览器内运行非法的```HTML```标签或```JavaScript```进行的一种攻击。

假设页面中存在一个```input```或者```textarea```用来收集用户输入的数据，正常情况下不会有什么问题，假设用户输入的内容为```<script>alert(1)</script>```。当我们将用户输入的这段内容通过```innnerHTML```添加到页面中时，就会运行该段代码，弹出```alert```。

用户输入的```js```脚本是可以被执行的，这就形成了安全漏洞，通过```url```参数攻击叫做反射型，还有一种叫做存储型。
通过```input```输入如果被存储到数据库，每次打开页面都会执行。

因为黑客注入网页的事一段js，所以js能做什么，他就可以做什么。比如：

1. 获取页面数据

2. 获取Cookies

3. 修改前端逻辑

4. 发送请求

5. 获取用户的信息和登录态

6. 欺骗用户

防范XSS可以在header中设置响应头 X-XSS-Protection，默认情况下禁止XSS攻击的，如果检测到url中存在XSS攻击，页面是拒绝访问的。但是他对存储型的攻击是无效的。

```js
ctx.set('X-XSS-Protection', 0); // 允许XSS攻击
```

0: 允许XSS攻击

1: 禁止XSS攻击。如果检测到跨站脚本攻击，浏览器将清除页面(删除不安全的部分)

1;mode=block 启用XSS过滤，如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。

1report=<reporting-URI> 启用XSS过滤，如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri 指令的功能发送违规报告。

通常情况下浏览器会默认设置为1，禁止XSS攻击。

浏览器推出CSP内容安全策略(```CSP Content Security Policy```) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，```CSP```本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行，只需要配置规则，如何拦截是浏览器自己实现的，

```s

# 只允许加载本站资源
Content-Security-Policy: default-src 'self'

# 只允许加载HTTPS协议图片
Content-Security-Policy: img-src https://*

# 不允许加载任何来源框架
Content-Security-Policy: child-src 'none'
```

切记用户输入永远不可信任的，最普遍的做法就是转译输出的内容，对于引号，尖括号，斜杠进行转译，比如通过如下的函数，对用户输入的内容进行转译。

```js
function escape(str) {
    str = str.replace(/&/g, '&amp;');
    str = str.replace(/</g, '&lt;');
    str = str.replace(/>/g, '&gt;');
    str = str.replace(/"/g, '&quto;');
    str = str.replace(/'/g, '&#39;');
    str = str.replace(/`/g, '&#96;');
    str = str.replace(/\//g, '&#x2F;');
    return str;
}

escape('<script>alert(123)</script>'); // &lt;script&gt;alert(123)&lt;&#x2F;script&gt;
```

这种转译叫做黑名单转义，就是把不安全的东西进行转译，比如说```\<\>```, 但是有一种情况是不能进行黑名单转译的。

有时要处理一些富文本，显然不能通过上面的办法来转译所有字符，因为这样会把需要的格式也过滤掉，对于这种情况，通常采用白名单过滤的办法，当然黑名单也可以，只是要过滤的标签和标签属性实在太多。

白名单的方式就是允许一部分安全的字符通过，其他的字符全部转译，这里推荐使用```xss```的```npm```包来处理。

```js
// 引入xss
const xss = require('xss');
let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss")</script>');
// <h1 id="title">XSS Demo</h1>&lt;script&gt;alert("xss")&lt;/script&gt;
console.log(html);
```

一般情况用户输入的数据或者从```url```中获取的参数我们不建议直接使用```innnerHTML```插入到页面中，除了```xss```模块和```escape```方法还可以引入```html```模板，常见的是```ejs```模板。```react```,```vue```,```angular```等框架默认已经处理了```xss```。

HttpOnly Cookie

可以通过禁止```js```访问```cookie```的方式防范这种攻击。这是预防```XSS```攻击窃取用户```cookie```最有效的防御手段，应用程序在设置```cookie```时，将其属性设为```HttpOnly```, 就可以避免该网页的```cookie```被客户端恶意```javaScript```窃取，保护用户```cookie```信息。也就是服务在设置```cookie```的时候跟上```HttpOnly```即可。

```js
response.addHeader('Set-Cookie', 'uid=112; path/; HttpOnly')
```

## CSRF

```CSRF( Cross Site Request Forgery)```，即跨站请求伪造，是一种常见的```web```攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义来完成非法操作。

假如用户已经登录了站点```A```, 并且在```A```站点记录了登录状态，在用户没有登出站点```A```的情况下，也就是登录态还有效时，访问了恶意攻击者提供的引诱危险站点```B```,```B```站点调用```A```站点的某个接口，比如说提交接口。如果```A```站点没有做任何的```CSRF```防御，就会被攻击。

原理也很简单，因为```B```站点调用了```A```站点的提交接口，根据```cookie```匹配原则，调用哪个站点的接口就会携带哪个站点的```cookie```，携带的就是用户存在```A```站点的```cookie```，这个时候提交接口传递的参数实际上是```B```站点提供的。在用户无意识的情况下以用户的身份调用了接口。

很多人可能会觉得，```B```站点调用```A```站点的接口跨域了啊，那怎么行。这没什么，跨域只是一种说法而已一般的跨域是前端拿不到接口的返回值，但不代表请求发不出去，这种攻击只要请求发出去了就达到攻击的目的了，返回值什么的都无所谓了。

防御```CSRF```的手段有三种。

第一个是禁止第三方网站携带```Cookie```，但是有兼容性问题，第二个方式是验证请求传递过来的```referrer```，判断是不是一个合法的```referrer```。其实很多的防盗链都是验证```referrer```的方式。

```referrer```就是发送请求的那个前端页面地址，可以通过```referrer```的方法进行屏蔽和过滤，但是他也有一个问题```https```是不发送```referrer```的，所以也算是兼容性的问题。

目前最有效的方式还是验证码的方式或者人机交互的方式，以前可以通过CSRF调取用户资金，因为转账比较简单，但现在基本转账都会发送验证码之类的验证。

## 点击劫持

点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过```iframe```嵌套的方式嵌入自己的网页中，并将```iframe```设置为透明，在页面中透出一个按钮诱导用户点击。

当你点击这个按钮的时候实际上是点击到了```iframe```中的某个按钮上，触发```iframe```嵌入网站的功能，比如想要给一个页面点赞，就可以把这个页面通过```iframe```伪装。

要防御这个其实很简单，只需要设置```X-FRAME-OPTIONS```响应头，```X-FRAME-OPTIONS```是一个```http```响应头，在现在浏览器有一个很好的支持，这个```http```响应头就是为了防御用```iframe```嵌套的点击劫持攻击。

该响应头有三个值可选分别是

```DENY```表示页面不允许通过```iframe```的方式展示

```SAMEORIGIN```表示页面可以在相同域名下通过```iframe```的方式展示

```ALLOW-FROM```表示页面可以在指定来源的```iframe```中展示

```js
ctx.set('X-FRAME-OPTIONS', 'DENY')
```

也可直接通过js判断是否在```iframe```中，不过该方法也有问题，跨域情况下内层的页面是无法操作外层的```location```的。

```js
if (self !== top) {
    top.location.href = self.location.href; // 将外层的location修改为内层的location
    document.body.innnerHTML = ''; // 清除页面内容
}
```

## SQL注入

```SQL```注入是比较常见的网络攻击方式之一，它不是利用操作系统的```BUG```来实现攻击，而是针对程序员编写时的疏忽，通过```SQL```语句，实现无账号登录，甚至篡改数据库。```SQL```注入攻击比较偏向后端，前端同学了解即可。

假设我们的```sql```是下面这个样子的，查询数据库用户表中是否存在用户名为```userName```变量，密码为```password```变量的用户。

```js
const sql = 'select * from user_table where username= "'+ userName +'" and password =