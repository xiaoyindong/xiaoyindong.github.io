## 原始类型

在 JS 中，存在着7种原始值(Primitive)。

- boolean
- null
- undefined
- number
- string
- symbol
- bigint

其中 JS 的 number 类型是浮点类型的，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3。

typeof null 会输出 object，这是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

## 对象类型

对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

当将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变。

typeof 对于原始类型来说，除了 null 都可以显示正确的类型，对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型。

如果我们想判断一个对象的正确类型，可以考虑使用 instanceof，因为内部机制是通过原型链来判断的。对于原始类型来说，想直接通过 instanceof 来判断类型是不行的，当然有办法让 instanceof 判断原始类型。

```js
lass PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

## 隐式转换

对象转字符串，先尝试调用对象的 toString()，对象无 toString(）或 toString 返回非原始值，调用 valueOf() 方法将该值转为字符串，并返回字符串结果，否则，抛出类型错误。

对象转数字，先尝试调用对象的 valueOf()，将返回原始值转为数字，对象无 valueOf() 或 valueOf 返回不是原始值，调用 toString() 方法，将返回原始值转为数字，否则，抛出类型错误。

```js
const a = {
	count: 0,
	valueOf() {
		return ++this.count
	}
}
a==1 && a==2 && a==3 // true
```

1. 首先会判断两者类型是否相同。相同的话就是比大小了
2. 类型不相同的话，那么就会进行类型转换
3. 会先判断是否在对比 null 和 undefined，是的话就会返回 true
4. 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number
5. 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断
6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断

## 闭包

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```js
for (var i = 1; i <= 5; i++) {
  ;(function(j) {
    setTimeout(function timer() {
      console.log(j)
    }, j * 1000)
  })(i)
}
```

## 深浅拷贝

浅拷贝可以通过 Object.assign 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。


