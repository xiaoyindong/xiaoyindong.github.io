## 1. 引用计数算法

在内部通过引用计数器来维护当前对象的引用数，从而判断该对象的引用数值是否为```0```来决定他是不是一个垃圾对象。当这个数值为```0```的时候```GC```就开始工作，将其所在的对象空间进行回收和释放。

引用计数器的存在导致了引用计数在执行效率上可能与其它的```GC```算法有所差别。

引用的数值发生改变是指某一个对象的引用关系发生改变的时候，这时引用计数器会主动的修改当前这个对象所对应的引用数值。例如代码里有一个对象空间，有一个变量名指向他，这个时候数值```+1```，如果又多了一个对象还指向他那他再```+1```，如果是减小的情况就```-1```。当引用数字为```0```的时候，```GC```就会立即工作，将当前的对象空间进行回收。

通过简单的代码来说明一下引用关系发生改变的情况。

```js
const user1 = {age: 11};
const user2 = {age: 22};
const user3 = {age: 33};

const nameList = [user1.age, user2.age, user3.age,];

function fn() {
    num1 = 1;
    num2 = 2;
}

fn();
```

从全局的角度考虑会发现```window```的下边是可以直接找到```user1```，```user2```，```user3```以及```nameList```，同时在```fn```函数里面定义的```num1```和```num2```由于没有设置关键字，所以同样是被挂载在```window```对象下的。这时候对这些变量而言他们的引用计数肯定都不是```0```。

接着在函数内直接把```num1```和```num2```加上关键字的声明，就意味着当前这个```num1```和```num2```只能在作用域内起效果。所以，一旦函数调用执行结束之后，从外部全局的地方出发就不能找到```num1```和```num2```了，这个时候```num1```和```num2```身上的引用计数就会回到```0```。此时此刻只要是```0```的情况下，```GC```就会立即开始工作，将```num1```和```num2```当做垃圾进行回收。也就是说这个时候函数执行完成以后内部所在的内存空间就会被回收掉。

```js
const user1 = {age: 11};
const user2 = {age: 22};
const user3 = {age: 33};

const nameList = [user1.age, user2.age, user3.age,];

function fn() {
    const num1 = 1;
    const num2 = 2;
}

fn();
```

由于```userList```，里面刚好都指向了上述三个对象空间，所以脚本即使执行完一遍以后```user1```，```user2```，```user3```他里边的空间都还被人引用着。所以此时的引用计数器都不是```0```，也就不会被当做垃圾进行回收。这就是引用计数算法实现过程中所遵循的基本原理。简单的总结就是靠着当前对象身上的引用计数的数值来判断是否为```0```，从而决定他是不是一个垃圾对象。

引用计数算法的优点总结出两条。

第一是引用计数规则会在发现垃圾的时候立即进行回收，因为他可以根据当前引用数是否为```0```来决定对象是不是垃圾。如果是就可以立即进行释放。

第二就是引用计数算法可以最大限度的减少程序的暂停，应用程序在执行的过程当中，必然会对内存进行消耗。当前执行平台的内存肯定是有上限的，所以内存肯定有占满的时候。由于引用计数算法是时刻监控着内存引用值为```0```的对象，举一个极端的情况就是，当他发现内存即将爆满的时候，引用计数就会立马找到那些数值为```0```的对象空间对其进行释放。这样就保证了当前内存是不会有占满的时候，也就是所谓的减少程序暂停的说法。

引用计数的缺点同样给出两条说明。

第一个就是引用计数算法没有办法将那些循环引用的对象进行空间回收的。通过代码片段演示一下，什么叫做循环引用的对象。

定义一个普通的函数```fn```在函数体的内部定义两个变量，对象```obj1```和```obj2```，让```obj1```下面有一个```name```属性然后指向```obj2```，让```obj2```有一个属性指向```obj1```。在函数最后的地方```return```返回一个普通字符，当然这并没有什么实际的意义只是做一个测试。接着在最外层调用一下函数。

```js
function fn() {
    const obj1 = {};
    const obj2 = {};

    obj1.name = obj2;
    obj2.name = obj1;

    return 'yd is a coder';
}
```

那么接下来分析还是一样的道理，函数在执行结束以后，他内部所在的空间肯定需要有涉及到空间回收的情况。比如说```obj1```和```obj2```，因为在全局的地方其实已经不再去指向他了，所以这个时候他的引用计数应该是为```0```的。

但是这个时候会有一个问题，在里边会发现，当```GC```想要去把``obj1``删除的时候，会发现```obj2```有一个属性是指向```obj1```的。换句话讲就是虽然按照之前的规则，全局的作用域下找不到```obj1```和```obj2```了，但是由于他们两者之间在作用域范围内明显还有着一个互相的指引关系。这种情况下他们身上的引用计数器数值并不是```0```，```GC```就没有办法将这两个空间进行回收。也就造成了内存空间的浪费，这就是所谓的对象之间的循环引用。这也是引用计数算法所面临到的一个问题。

第二个问题就是引用计数算法所消耗的时间会更大一些，因为当前的引用计数，需要维护一个数值的变化，在这种情况下要时刻的监控着当前对象的引用数值是否需要修改。对象数值的修改需要消耗时间，如果说内存里边有更多的对象需要修改，时间就会显得很大。所以相对于其他的```GC```算法会觉得引用计数算法的时间开销会更大一些。

## 2. 标记清除算法

清除算法的原理很简单，而且还能解决一些相应的问题。将整个垃圾回收操作分成两个阶段，第一个阶段遍历所有对象然后找到活动对象进行标记。活动就像跟之前提到的可达对象是一个道理，第二个阶段仍然会遍历所有的对象，把没有标记的对象进行清除。同时第二个阶段当中也会把第一个阶段设置的标记抹掉，便于```GC```下次能够正常工作。这样一来就可以通过两次遍历行为把当前垃圾空间进行回收，最终再交给相应的空闲列表进行维护，后续的程序代码就可以使用了。

这里举例说明。

在全局```global```声明```A```，```B```，```C```三个可达对象，找到这三个可达对象之后，会发现他的下边还会有一些子引用，这也就是标记清除算法强大的地方。如果发现他的下边有孩子，甚至孩子下边还有孩子，这个时候他会用递归的方式继续寻找那些可达的对象，比如说```D```，```E```分别是```A```和```C```的子引用，也会被标记成可达的。

这里还有两个变量```a1```和```b1```，他们在函数内的局部作用域，局部作用域执行完成以后这个空间就被回收了。所以从```global```链条下是找不到```a1```和```b1```的，这时候```GC```机制就会认为他是一个垃圾对象，没有给他做标记，最终在```GC```工作的时候就会把他们回收掉。

```js

const A = {};

function fn1() {
    const D = 1;
    A.D = () => {
        console.log(D);
    };
}

fn1();

const B;

const C = {};

function fn2() {
    const E = 2;
    C.E = () => {
        console.log(E);
    };
}

fn2();

function fn3() {
    const a1 = 3;
    const b1 = 4;
}

fn3();

```

简单的整理可以分成两个步骤。在第一阶段要找到所有可达对象，如果涉及到引用的层次关系，会递归进行查找。找完以后会将这些可达对象进行标记。标记完成以后进行第二阶段开始做清除，找到那些没有做标记的对象，同时还将第一次所做的标记清除掉。这样就完成了一次垃圾回收，同时还要留意，最终会把回收的空间直接放在一个空闲列表上。方便后续的程序可以直接在这申请空间。

相对比引用计数而言标记清除具有一个最大的优点，就是可以解决对象循环引用的回收操作。在写代码的时候可能会在全局定义```A```、```B```、```C```这样的可达对象，也会有一些函数的局部作用域，比如在函数内定义了```a1```和```b1```，而且让他们互相引用。

```js
const A = {};

const B;

const C = {};

function fn() {
    const a1 = {};
    const b1 = {};
    a1.value = b1;
    b1.value = a1;
}

fn();

```

函数的调用在结束之后必然要去释放他们内部的空间，在这种情况下一旦当某一个函数调用结束之后他局部空间中的变量就失去了与全局```global```作用域上的链接。这个时候```a1```和```b1```在```global```根下边就没办法访问到了，就是一个不可达的对象。不可达对象在做标记阶段的时候不能够完成标记，在第二个阶段回收的时候就直接进行释放了。

这是标记清除可以做到的，但是在引用计数里面，函数调用结束同时也没有办法在全局进行访问。可是由于当前判断的标准是引用数字是否为```0```，在这种情况下，就没有办法释放```a1```和```b1```空间，这就是标记清除算法的最大优点，当然这是相对于引用计数算法而言的。

同时标记清除算法也会有一些缺点。比如模拟一个内存的存储情况，从根进行查找，在下方有一个可达对象```A```对象, 左右两侧有一个从跟下无法直接查找的一个区域，``B``和```C```。这种情况下在进行第二轮清除操作的时候，就会直接将B和C所对应的空间进行回收。然后把释放的空间添加到空闲列表上，后续的程序可以直接从空闲列表上申请相应的一个空间地址，进行使用。在这种情况下就会有一个问题。

```js


function fn() {
    const B = '两个';
}
fn();

const A = '四个文字';

function fn2() {
    const C = '一个';
}
fn2();

```

比如我们认为，任何一个空间都会有两部分组成，一个用来存储空间一些元信息比如他的大小，地址，称之为头。还有一部分是专门用于存放数据的叫做域，```B```、```C```空间认为```B```对象有```2```个字的空间，```C```对象有```1```个字的空间。这种情况下，虽然对他进行了回收，加起来好像是释放了```3```个字的空间，但是由于它们中间被A对象去分割着。所以在释放完成之后其实还是分散的也就是地址不连续。

这点很重要，后续想申请的空间地址大小刚好```1.5```个字。这种情况下，如果直接找到B释放的空间会发现是多了的，因为还多了```0.5```个，如果直接去找```C```释放的空间又发现不够，因为是```1```个。所以这就带来了标记清除算法中最大的问题，空间的碎片化。

所谓的空间碎片化，就是由于当前所回收的垃圾对象在地址上本身是不连续的，由于这种不连续从而造成了回收之后分散在各个角落，后续要想去使用的时候，如果新的生成空间刚好与他们的大小匹配，就能直接用。一旦是多了或是少了就不太适合使用了。

这就是标记清除算法优点和缺点，简单的整理一下就是优点是可以解决循环引用不能回收的问题，缺点是说会产生空间碎片化的问题，不能让空间得到最大化的使用。

## 3. 标记整理算法

首先认为标记整理算法是标记清除的增强操作，他们在第一个阶段是完全一样的，都会去遍历所有的对象，然后将可达活动对象进行标记。第二阶段清除时，标记清除是直接将没有标记的垃圾对象做空间回收，标记整理则会在清除之前先执行整理操作，移动对象的位置，让他们能够在地址上产生连续。

假设回收之前有很多的活动对象和非活动对象，以及一些空闲的空间，当执行标记操作的时候，会把所有的活动对象进行标记，紧接着会进行整理的操作。整理其实就是位置上的改变，会把活动对象先进行移动，在地址上变得连续。紧接着会将活动对象右侧的范围进行整体的回收，这相对标记清除算法来看好处是显而易见的。

因为在内存里不会大批量出现分散的小空间，从而回收到的空间都基本上都是连续的。这在后续的使用过程中，就可以尽可能的最大化利用所释放出来的空间。

## 4. 执行时机

引用计数可以及时回收垃圾对象，只要数值```0```的就会立即让```GC```找到这片空间进行回收和释放。正是由于这个特点的存在，引用计数可以最大限度的减少程序的卡顿，因为只要这个空间即将被占满的时候，垃圾回收器就会进行工作，将内存进行释放，让内存空间总有一些可用的地方。

标记清除不能立即回收垃圾对象，而且清除的时候程序是停止工作的。即便第一阶段发现了垃圾，也要等到第二阶段清除的时候才会回收掉。

## 5. V8引擎

```V8```的速度之所以快，除了有一套优秀的内存管理机制之外，还有一个特点就是采用及时编译。很多的```JavaScript```引擎都需要将源代码转成字节码才能执行，而```V8```可以将源码翻译成直接执行的机器码。

```V8```的内存是有上限的，64位操作系统不超过```1.5G```，```32```位的操作系统中不超过```800M```。

为什么```V8```要采用这样的做法呢，原因基本上可以从两方面进行说明。

第一```V8```本身就是为了浏览器制造的，所以现有的内存大小足够使用了。再有```V8```内部所实现的垃圾回收机制也决定了他采用这样一个设置是非常合理的。因为官方做过一个测试，当垃圾内存达到```1.5```个```G```的时候，```V8```去采用增量标记的算法进行垃圾回收只需要消耗```50ms```，采用非增量标记的形式回收则需要```1s```。从用户体验的角度来说```1s```已经算是很长的时间了，所以就以```1.5G```为界了。

## 6. V8垃圾回收策略

程序运行过程中，数据是是分别存储在栈和堆中的，栈中主要存储的是原始类型，堆中存储的则是体积较大的引用类型。

对于栈来说，执行上下文执行完毕弹栈之后，当前的内存空间会自动被清理，供下个执行上下文入栈使用，所以栈中的数据也一并被清理掉了。

针对堆中的数据```V8```采用的是分代回收的思想，把内存空间按照一定的规则分成两类，新生代存储区和老生代存储区。针对不同代采用最高效的```GC```算法，从而对不同的对象进行回收操作。新生代对象在64位操作系统中大小是```32M```，在```32```位的操作系统中是```16M```。

副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。

## 7. 回收新生代对象

通常情况大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代对象回收所采用到的算法主要是复制算法和标记整理算法，会将空间也分成两个部分，```From```和```To```，而且这两个部分的大小是相等的，将From空间称为使用状态，```To```空间叫做空闲状态。有了这样两个空间之后代码执行的时候如果需要申请空间首先会将所有的变量对象都分配至```From```空间。也就是说在这个过程中```To```是空闲的，一旦```From```空间应用到一定的程度之后，就要触发```GC```操作。这个时候就会采用标记整理对```From```空间进行标记，找到活动对象，然后将他们拷贝到To空间，并且变得连续，拷贝之后直接把```From```空间完全释放，然后将From和To调换位置。原来的```To```就变成了```From```，原来的```From```就变成了```To```。这样就算完成了空间的释放和回收。

如果新生代中的某些对象经过一轮```GC```之后他还活着。这个时候就可以把他拷贝至老年代存储区，进行存储。除此之外如果当前拷贝的过程中，发现```To```空间的使用率超过了```25%```，这个时候也需要将这一次的活动对象都移动至老生代中存放。

因为将来进行回收操作的时候，最终是要把```From```空间和```To```空间进行交换的。也就是说以前的```To```会变成```From```，而以前的```From```要变成```To```，这就意味着```To```如果使用率达到了```80%```，最终变成活动对象的存储空间后，新的对象好像存不进去了。

## 8. 回收老生代对象

在```64```位操作系统中大小是```1.4G```, 在```32```位操作系统中是```700M```。老生代垃圾回收主要采用的是标记清除，标记整理和增量标记三个算法。

标记清除算法完成垃圾空间的释放和回收，当需要把新生代里的内容向老生代中移动的时候，而且这个时间节点上老生代存储区域的空间不足以存放新生代存储区移过来的对象。就会触发标记整理，把之前的一些锁片空间进行整理回收，让程序有更多的空间可以使用。最后还会采用增量标记的方式对回收的效率进行提升。

这里来对比一下新老生代垃圾回收。

新生代的垃圾回收更像是在用空间换时间，因为他采用的是复制算法，这也就意味着每时每刻他的内部都会有一个空闲空间的存在。但是由于新生代存储区本身的空间很小，所以分出来的空间更小，这部分的空间浪费相比带来的时间上的一个提升当然是微不足道的。

老生代存储空间是比较大的，如果一分为二就有几百兆的空间浪费，太奢侈了。第二就是老生代存储区域中所存放的对象数据比较多，所以在复制的过程中消耗的时间也就非常多，因此老生代的垃圾回收是不适合使用复制算法来实现的。

增量标记算法分成两个部分，一个是程序执行，另一个是垃圾回收。

垃圾回收整个进行工作的时候是会阻塞当前程序执行的，也就是会出现一个空档期，程序会停下来执行垃圾回收操作。标记增量简单来讲就是将整段的垃圾回收操作拆分成多个小步骤，分片完成整个回收，替代一口气做完的垃圾回收操作。

可以实现垃圾回收与程序执行交替完成，带来的时间消耗更加合理。避免程序执行时不能做垃圾回收，程序垃圾回收时不能运行程序。

程序运行的时候是不需要进行垃圾回收的，一旦触发了垃圾回收就，就要遍历并且做标记，标记可以分段执行，因为存在直接可达和间接可达操作，也就是说如果可以先找到第一层的可达对象。然后就停下来让程序再去执行一会，再继续让```GC```机做第二步的标记操作，比如下面还有一些子元素也是可达的，那就继续做标记。标记一轮之后再让GC停下来，继续回到程序执行，也就是交替的去做标记和程序执行。

标记操作完成以后再去完成垃圾回收，不过这段时间程序就要停下来，等到垃圾回收操作完成才会继续执行。虽然看起来程序停顿了很多次，但是整个```V8```最大的垃圾回收也就是当内存达到```1.5G```的时候，采用非增量标记的形式进行垃圾回收时间也不超过```1s```，所以这里程序的间断是合理的。而且这样一来最大限度的把以前很长的一段停顿时间直接拆分成了更小段，针对用户体验会显得更加流畅一些。

标记阶段会将没有标记的空间添加到空闲列表，再执行阶段需要空间可以从空闲列表中申请。
