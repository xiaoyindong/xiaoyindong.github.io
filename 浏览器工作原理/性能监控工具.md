## Performance工具介绍

```GC```工作目的就是为了让内存空间在程序运行的过程中，出现良性的循环使用。所谓良性循环的基础其实就是要求开发者在写代码的时候能够对内存空间进行合理的分配。但是由于```ECMAScript```中并没有给程序员提供相应的操作内存空间的```API```，所以是否合理好像也不知道，因为他都是由GC自动完成的。

如果想判断整个过程内存使用是否合理，必须想办法能够时刻关注到内存的变化。所以就有了这样一款工具可以提供给开发者更多的监控方式，在程序运行过程中帮助开发者完成对内存空间的监控。

通过使用```Performance```可以对程序运行过程内存的变化实时的监控。这样就可以在程序的内存出现问题的时候直接想办法定位到出现问题的代码快。下面来看一下```Performance```工具的基本使用步骤。

首先打开浏览器，在地址栏输入网址。输入完地址之后不建议立即进行访问，因为想把最初的渲染过程记录下来，所以只是打开界面输入网址即可。紧接着打开开发人员工具面板(```F12```)，选择性能选项。开启录制功能，开启之后就可以访问目标网址了。在这个页面上进行一些操作，过一段时间后停止录制。

就可以得到一个报告，在报告当中就可以分析跟内存相关的信息了。录制后会有一些图表的展示，信息也非常的多，看起来比较麻烦。这里主要关注与内存相关的信息，有一个内存的选项(```Memory```)。默认情况下如果没有勾选需要将它勾选。页面上可以看到一个蓝色的线条。属于整个过程中我内存所发生的变化，可以根据时序，来看有问题的地方。如果某个地方有问题可以具体观察，比如有升有降就是没问题的。

## 1. 内存问题的体现

当程序的内存出现问题的时候，具体会表现出什么样的形式。

首先第一条，界面如果出现了延迟加载或者说经常性的暂停，首先限定一下网络环境肯定是正常的，所以出现这种情况一般都会去判定内存是有问题的，而且与```GC```存在着频繁的垃圾回收操作是相关的。也就是代码中肯定存在瞬间让内存爆炸的代码。这样的代码是不合适的需要去进行定位。

第二个就是当界面出现了持续性的糟糕性能表现，也就是说在使用过程中，一直都不是特别的好用，这种情况底层一般会认为存在着内存膨胀。所谓的内存膨胀指的就是，当前界面为了达到最佳的使用速度，可能会申请一定的内存空间，但是这个内存空间的大小，远超过了当前设备本身所能提供的大小，这个时候就会感知到一段持续性的糟糕性能的体验，同样肯定是假设当前网络环境是正常的。

最后，当使用一些界面的时候，如果感知到界面的使用流畅度，随着时间的加长越来越慢，或者说越来越差，这个过程就伴随着内存泄露，因为在这种情况下刚开始的时候是没有问题的，由于我们某些代码的出现，可能随着时间的增长让内存空间越来越少，这也就是所谓的内存泄漏，因此，出现这种情况的时候界面会随着使用时间的增长表现出性能越来越差的现象。

这就是关于应用程序在执行过程中如果遇到了内存出现问题的情况，具体的体现可以结合```Performance```进行内存分析操作，从而定位到有问题的代码，修改之后让应用程序在执行的过程中显得更加流畅。

## 2. 监控内存的几种方式

内存出现的问题一般归纳为三种：内存泄露，内存膨胀，频繁的垃圾回收。当这些内容出现的时候，该以什么样的标准来进行界定呢？

内存泄露其实就是内存持续升高，这个很好判断，当前已经有很多种方式可以获取到应用程序执行过程中内存的走势图。如果发现内存一直持续升高的，整个过程没有下降的节点，这也就意味着程序代码中是存在内存泄露的。这个时候应该去代码里面定位相应的模块。

内存膨胀相对的模糊，内存膨胀的本意指的是应用程序本身，为了达到最优的效果，需要很大的内存空间，在这个过程中也许是由于当前设备本身的硬件不支持，才造成了使用过程中出现了一些性能上的差异。想要判定是程序问题还是设备问题，应该多做一些测试。这个时候可以找到那些深受用户喜爱的设备，在他们上面运行应用程序，如果整个过程中所有的设备都表现出了很糟糕的性能体验。这就说明程序本身是有问题的，而不是设备有问题。这种情况就需要回到代码里面，定位到内存出现问题的地方。

具体有哪些方式来监控内存的变化，主要还是采用浏览器所提供的一些工具。

浏览器所带的任务管理器，可以直接以数值的方式将当前应用程序在执行过程中内存的变化体现出来。第二个是借助于```Timeline```时序图，直接把应用程序执行过程中所有内存的走势以时间点的方式呈现出来，有了这张图就可以很容易的做判断了。再有浏览器中还会有一个叫做堆快照的功能，可以很有针对性的查找界面对象中是否存在一些分离的```DOM```，因为分离```DOM```的存在也就是一种内存上的泄露。

至于怎样判断界面是否存在着频繁的垃圾回收，这就需要借助于不同的工具来获取当前内存的走势图，然后进行一个时间段的分析，从而得出判断。

## 3. 任务管理器监控内存

一个```web```应用在执行的过程中，如果想要观察他内部的一个内存变化，是可以有多种方式的，这里通过一段简单的```demo```来演示一下，可以借助浏览器中自带的任务管理器监控脚本运行时内存的变化。

在界面中放置一个元素，添加一个点击事件，事件触发的时候创建一个长度非常长的一个数组。这样就会产生内存空间上的消耗。

```html
<body>
    <button id="btn">add</button>
    <script>
        const oBtn = document.getElementById('btn');
        oBtn.onclick = function() {
            let arrList = new Array(1000000)
        }
    </script>
</body>
```

完成之后打开浏览器运行，在右上角的```更多```中找到```更多工具```找到```任务管理器```打开。

这个时候就可以在任务管理器中定位到当前正在执行的脚本，默认情况下是没有```JavaScript```内存列的，如果需要可以直接右击找到``JavaScript``内存展示出来。这里最关注的是内存和```JavaScript```内存这两列。

第一列内存表示的是原生内存，也就是当前界面会有很多```DOM```节点，这个内存指的就是``DOM``节点所占据的内存，如果这个数值在持续的增大，就说明界面中在不断的创建DOM元素。

```JavaScript```内存表示的是```JavaScript```的堆，在这列当中需要关注的是小括号里面的值，表示的是界面中所有可达对象正在使用的内存大小，如果这个数值一直在增大，就意味着当前的界面中要么在创建新对象，要么就是现有对象在不断的增长。

以这个界面为例，可以发现小括号的值一直是个稳定的数字没有发生变化，也就意味着当前页面是没有内存增长的。此时可以再去触发一下```click```事件(点击按钮)，多点几次，完成以后就发现小括号里面的数值变大了。

通过这样的过程就可以借助当前的浏览器任务管理器来监控脚本运行时整个内存的变化。如果当前```JavaScript```内存列小括号里面的数值一直增大那就意味着内存是有问题的，当然这个工具是没有办法定位的，他只能发现问题，无法定位问题。

## 4. TimeLine记录内容

在之前已经可以使用浏览器自带的任务管理器对脚本执行中内存的变化去进行监控，但是在使用的过程中可以发现，这样的操作更多的是用于判断当前脚本的内存是否存在问题。如果想要定位问题具体和什么样的脚本有关，任务管理器就不是那么好用了。

这里再介绍一个通过时间线记录内存变化的方式来演示一下怎样更精确的定位到内存的问题跟哪一块代码相关，或者在什么时间节点上发生的。

首先放置一个```DOM```节点，添加点击事件，在事件中创建大量的```DOM```节点来模拟内存消耗，再通过数组的方式配合着其他的方法形成一个非常长的字符串，模拟大量的内存消耗。


```html
<body>
    <button id="btn">add</button>
    <script>
        const oBtn = document.getElementById('btn');

        const arrList = [];

        function test () {
            for (let i = 0; i < 100000; i++) {
                document.body.appendChild(document.createElement('p'))
            }
            arrList.push(new Array(1000000).join('x'))
        }
        oBtn.onclick = test;
    </script>
</body>
```

先打开浏览器的控制台工具，选择性能面板，默认是没有运行的，也就是没有记录，需要先点击计时操作。点完以后就开始录制了，点击几次```add```按钮，稍等几秒后，点击停止按钮。完成以后就生成了一个图表，密密麻麻的东西看起来可能会有些头疼，只关注下想要看到的信息就可以了。

内存如果没有勾选的话是不会监控内存变化的，需要先勾选内存，勾选之后页面上就出现了内存的走势曲线图。里面会包含很多信息，给出来了几中颜色的解释。蓝色的是```JavaScript```堆，红色表示当前的文档，绿色是```DOM```节点，棕色是监听器，紫色是```CPU```内存。

为了便于观察可以只保留```JavaScript```堆，其他的取消勾选隐藏掉。可以看到这个脚本运行过程中到目前为止他的```JavaScript```堆的情况走势。当前这个工具叫时序图，也就是在第一栏，以毫秒为单位，记录了整个页面从空白到渲染结束到最终停状态，这个过程中整个界面的变化。如果愿意，可以点进去看一下当前的界面形态，如果只是关注内存，只看内存的曲线图就可以了。

当这个页面最开始打开的时候其实很长一段时间都是平稳的状态，没有太多的内存消耗。原因在根本没有点击```add```。然后紧接着在某一个时间点上突然之间内存就上去了，上去之后是一段平稳的状态，这是因为点击了```add```之后这里的内存肯定是瞬间暴涨的，然后紧接着暴涨之后我们任何操作，所以这时候肯定是平稳。

然后紧接着平稳之后又下降了，这就是之前所提到的，浏览器本身也是具有垃圾回收机制的，当的脚本运行稳定之后，```GC```可能在某个时间点上就开始工作了，会发现有一些对象是非活动的，就开始进行回收，所以一段平稳之后就降下去了。降下去之后又会有一些小的浮动，属于正常的活动开销。后来又有几次连续的点击，这个连续的点击行为可能又造成内存的飙升，然后不操作之后又往下降。

通过这样一张内存走势图，可以得出的结论是，脚本里面内存是非常稳定的，整个过程有涨有降，涨是申请内存，降是用完之后我```GC```在正常的回收内存。

一旦看到内存的走势是直线向上走，也就意味着他只有增长而没有回收，必然存在着内存消耗，更有可能是内存泄漏。可以通过上面的时序图定位问题，当发现某一个节点上有问题的时候，可以直接在这里面定位到那个时间节点，可以在时序图上进行拖动查看每一个时间节点上的内存消耗。还可以看到界面上的变化，就可以配合着定位到是哪一块产生了这样一个内存的问题。

所以相对任务管理器来说会更好用，不但可以看当前内存是否有问题，还可以帮助定位问题在哪个时候发生的，然后再配合当前的界面展示知道做了什么样的操作才出现了这个问题，从而间接地可以回到代码中定位有问题的代码块。

## 5. 堆快照查找分离DOM

这里简单说明一下堆快照功能工作的原理，首先他相当于找到```JavaScript```堆，然后对它进行照片的留存。有了照片以后就可以看到它里面的所有信息，这也就是监控的由来。堆快照在使用的时候非常的有用，因为他更像是针对分离DOM的查找行为。

界面上看到的很多元素其实都是```DOM```节点，而这些```DOM```节点本应该存在于一颗存活的DOM树上。不过DOM节点会有几种形态，一种是垃圾对象，一种是分离```DOM```。简单的说就是如果这个节点从```DOM```树上进行了脱离，而且在```JavaScript```代码当中没有再引用的```DOM```节点，他就成为了一个垃圾。如果```DOM```节点只是从```DOM```树上脱离了，但是在```JavaScript```代码中还有引用，就是分离```DOM```。分离```DOM```在界面上是看不见的，但是在内存中是占据着空间的。

这种情况就是一种内存泄露，可以通过堆快照的功能把他们找出来，只要能找得到，就可以回到代码里，针对这些代码进行清除从而让内存得到一些释放，脚本在执行的时候也会变得更加迅速。

在```html```里面放入```btn```按钮，添加点击事件，点击按钮的时候，通过```JavaScript```语句去模拟相应的内存变化，比如创建```DOM```节点，为了看到更多类型的分离```DOM```，采用```ul```包裹```li```的```DOM```节点创建。先在函数中创建```ul```节点，然后使用循环的方式创建多个```li```放在```ul```里面，创建之后不需要放在页面上，为了让代码引用到这个```DOM```使用变量```tmpEle```指向```ul```。

```html
<body>
    <button id="btn">add</button>
    <script>
        const oBtn = document.getElementById('btn');

        var tmpEle;

        function fn () {
            var ul = document.createElement('ul');
            for (var i = 0; i < 10; i++) {
                var li = document.createElement('li');
                ul.appendChild(li);
            }
            tmpEle = ul;
        }

        oBtn.addEventListener('click', fn);

    </script>
</body>
```

简单说明就是创建了```ul```和``li``节点，但是并没有将他们放在页面中，只是通过```JavaScript```变量引用了这个节点，这就是分离```DOM```。

打开浏览器调试工具，选中内存面板。进入以后可以发现堆快照的选项。这里做两个行为的测试，第一个是在没有点击按钮的情况下，直接获取当前的快照，在这个快照里面就是当前对象的具体展示，这里有一个筛选的操作，直接检索```deta```关键字，可以发现没有内容。

回到界面中做另外一个操作，对按钮进行点击，点完以后我再拍摄一张快照(点击左侧的配置文件文字，出现拍照界面)，还是做和之前一样的操作检索```deta```。

这次就会发现，快照```2```里面搜索到了，很明显这几个就是代码中所创建的DOM节点，并没有添加到界面中，但是他的确存在于堆中。这其实就是一种空间上的浪费，针对这样的问题在代码中对使用过后的DOM节点进行清空就可以了。

```js
function fn () {
    var ul = document.createElement('ul');
    for (var i = 0; i < 10; i++) {
        var li = document.createElement('li');
        ul.appendChild(li);
    }
    tmpEle = ul;
    // 清空DOM
    ul = null;
}
```

在这里我们简单的总结就是，我们可以利用浏览器当中提供的一个叫做堆快照的功能，然后去把我们当前的堆进行拍照，拍照过后我们要找一下这里面是否存在所谓的分离```DOM```。

因为分离```DOM```在页面中不体现，在内存中的确存在，所以这个时候他是一种内存的浪费，那么我们要做的就是定位到我们代码里面那些个分离```DOM```所在的位置，然后去想办法把他给清除掉。

## 6. 判断是否存在频繁GC

这里说一下如何确定当前web应用在执行过程中是否存在着频繁的垃圾回收。当```GC```去工作的时候应用程序是停止的。所以```GC```频繁的工作对```web```应用很不友好，因为会处于死的状态，用户会感觉到卡顿。

这个时候就要想办法确定当前的应用在执行时是否存在频繁的垃圾回收。

这里给出两种方式，第一种是可以通过```timeline```时序图的走势来判断，在性能工具面板中对当前的内存走势进行监控。如果发现蓝色的走势条频繁的上升下降。就意味着在频繁的进行垃圾回收。出现这样的情况之后必须定位到相应的时间节点，然后看一下具体做了什么样的操作，才造成这样现象的产生，接着在代码中进行处理就可以了。

任务管理器在做判断的时候会显得更加简单一些，因为他就是一个数值的变化，正常当界面渲染完成之后，如果没有其他额外的操作，那么无论是```DOM```节点内存，还是我们```JavaScript```内存，都是一个不变化的数值，或者变化很小。如果这里存在频繁的```GC```操作时，这个数值的变化就是瞬间增大，瞬间减小，这样的节奏，所以看到这样的过程也意味着代码存在频繁的垃圾回收操作。

频繁的垃圾回收操作表象上带来的影响是让用户觉得应用在使用的时候非常卡顿，从内部看就是当前代码中存在对内存操作不当的行为让```GC```不断的工作，来回收释放相应的空间。
