通常来讲前端性能优化是指从用户开始访问我们的网站到整个页面完整的展现出来的过程中，通过各种优化策略和优化方法让页面加载的更快，让用户的操作响应更及时，给用户更好的使用体验。这里介绍的是前端性能优化知识的解决方案，从静态资源优化开始入手，从表象深入体系化的讲解页面渲染架构，掌握高效的技术方案。

页面性能关乎到用户的留存，网站的转换率，用户体验和网站的传播，甚至影响搜索排名遭到用户投诉，当然也会影响开发的效率。本文并非细节的讲述如何实现性能优化，而是从各个方面介绍性能优化的方式方法，并且不仅限于H5，因为当今的前端也不仅仅只有H5。

## 性能指标

性能是相对的，对于一个用户而言在不同的网络环境下访问页面的速度可能是不同的，即使相同的网站在懒加载的情况下也会显得快。

在讨论性能的时候精确地，可量化的指标是很重要的。但是仅仅因为一个度量标准是基于客观准备并且可以定量的度量的，并不一定意味这些度量是有用的。对于```Web```开发人员来说，如何恒量一个```Web```页面的性能一直都是一个难题。

最初，开发人员使用```Time to To Byte```。```DomContentLoaded```和```Load```这些衡量文档加载进度的指标，但他们不能直接反应用户视觉体验。

为了恒量用户视觉体验，Web标准中定义了一些性能指标。这些性能指标被各大浏览器标准化实现，例如```First Paint```和```First Contentful Paint```。

还有一些由Web孵化器社区组提出的性能指标，如```Largest Contentful Paint```、```Time to Interactive```、```First Input Delay```、```First CPU Idle```。

另外还有```Google```提出的```First Meaningful Paint```、```Speed Index```。百度提出的```First Screen Paint```。

这些指标之间并不是毫无关联，而是在以用户为中心的目标中不断演进出来的，有的已经不再建议使用，有的被各种测试工具实现，有的则可以作为通用标准可用于生产环境测量的API。

### 1. RAIL性能模型

```RAIL```是```Response```，```Animation```，```Idle```和```Load```的首字母缩写，是一种由```Google Chrome```团队于```2015年```提出的性能模型，用于提升浏览器的用户体验和性能。

```RAIL```模型的理念是以用户为中心，最终目标并不是让你的网站在任何特定设备上都能运行很快，而是使用户满意。

```Response```应该尽可能快速的响应用户的操作，应在在```100ms```以内响应用户输入。

```Animation```在展示动画的时候，每一帧应该以```16ms```进行渲染，这样可以保持动画效果的一致性，并且避免卡顿。

```Idle```当使用```js```主线程的时候，应该把任务划分到执行时间小于```50ms```的片段中去，这样可以释放线程以进行用户交互。```50ms```为单位是为了保证用户在发生操作的```100ms```内做出响应。

要使网站响应迅速，动画流畅，通常都需要较长的处理时间，但以用户为中心来看待性能问题，就会发现并非所有工作都需要在响应和加载阶段完成，完全可以利用浏览器的空闲时间处理可延迟的任务，只要让用户感受不到延迟即可。利用空闲时间处理延迟可减少预加载的数据大小，以保证网站或应用快速完成加载。

```Load```应该在小于```1s```的时间内加载完成你的网站，并可以进行用户交互。根据网络条件和硬件的不同，用户对性能延迟的理解也有所不同，在```3G```网络需要花费更多的时间，```5s```是一个更现实的目标。

###  2. FCP (First Contentful Paint)

首次内容绘制，浏览器首次绘制来自```DOM```的内容的时间，内容必须包括文本，图片，非白色的```canvas```或```svg```，也包括带有正在加载中的```web```字体文本。这是用户第一次看到的内容。

| FCP时间(秒) | 颜色编码 | FPC分数 |
| -- | -- | -- |
| 0 - 2 | 绿色(快) | 75 - 100 |
| 2 - 4 | 橙色(中等) | 50 - 74 |
| 超过4 | 红色(慢) | 0 - 49 |

### 3. LCP (Largest Contentful Paint)

最大内容绘制，可视区域中最大的内容元素呈现到屏幕上的时间，用以估算页面的主要内容对用户的可见时间。```img```图片，```video```元素的封面，通过```url```加载到的北京，文本节点等，为了提供更好的用户体验，网站应该在```2.5s```以内或者更短的时间最大内容绘制。

| LCP时间(秒) | 颜色编码 |
| -- | -- |
| 0 - 2.5 | 绿色(快) |
| 2.5 - 4 | 橙色(中等) |
| 超过4 | 红色(慢) |

### 4. FID (First Input Delay)

首次输入延迟，从用户第一次与页面进行交互到浏览器实际能够响应该交互的时间，输入延迟是因为浏览器的主线程正忙于做其他事情，所以不能响应用户，发生这种情况的一个常见原因是浏览器正忙于解析和执行应用程序加载的大量计算的```JavaScript```。

| FID时间(毫秒) | 颜色编码 |
| -- | -- |
| 0 - 100 | 绿色(快) |
| 100 - 300 | 橙色(中等) |
| 超过300 | 红色(慢) |

### 5. TTI (Time to Interactive)

网页第一次完全达到可交互状态的时间点，浏览器已经可以持续的响应用户的输入，完全达到可交互的状态的时间是在最后一个长任务完成的时间，并且在随后的```5s```内网络和主线程是空闲的。从定义上来看，中文名称叫持续可交互时间或可流畅交互时间更合适。

| TTI时间(秒) | 颜色编码 |
| -- | -- |
| 0 - 3.8 | 绿色(快) |
| 3.9 - 7.3 | 橙色(中等) |
| 超过7.3 | 红色(慢) |

### 6. TBT (Total Block Time)

总阻塞时间，度量了```FCP```和```TTI```之间的总时间，在该时间范围内，主线程被阻塞足够长的时间以防止输入响应。只要存在长任务，该主线程就会被视为阻塞，该任务在主线程上运行超过```50```毫秒。

线程阻塞是因为浏览器无法中断正在进行的任务，因此如果用户确实在较长的任务中间与页面进行交互，则浏览器必须等待任务完成才能响应。

| TBT时间(毫秒) | 颜色编码 |
| -- | -- |
| 0 - 300 | 绿色(快) |
| 300 - 600 | 橙色(中等) |
| 超过600 | 红色(慢) |

### 7. CLS (Cumulative Layout Shift)

累计布局位移，```CLS```会测量在页面整个生命周期中发生的每个意外的布局移位的所有单独布局移位分数的总和，他是一种保证页面的视觉稳定性从而提升用户体验的指标方案。

用人话来说就是当点击页面中的某个元素的时候，突然布局变了，手指点到了其它位置。比如想点击页面的链接，突然出现了一个```banner```。这种情况可能是因为尺寸未知的图像或者视频。

| CLS时间(毫秒) | 颜色编码 |
| -- | -- |
| 0 - 0.1 | 绿色(快) |
| 0.1 - 0.25 | 橙色(中等) |
| 超过0.25 | 红色(慢) |

Web Vitals是谷歌指定的```web```性能指标标准，谷歌认为之前的标准太复杂，指标太多了，在```2020```年重新进行了梳理，简化到了三个。加载性能```LCP```，交互性```FID```，视觉稳定性```CLS```。只需要做好这三个，网站的性能基本上就可以了。测量```Web Vitals```的工具有很多，比如```Lighthouse```，```web-vitals```，浏览器插件```web vitals```。

### 1. Web-Vitals

```js
// npm install web-vitals -g

import { getLCP, getFID, getCLS } from 'web-vitals';

getCLS(conole.log)
getFID(conole.log)
getCLS(conole.log)
```

### 2. 浏览器插件

谷歌浏览器可以直接在插件市场中查找并且安装```web vitals```。安装完成之后浏览器的右上角会多出插件标志，点击就会显示页面的性能指标。

## 性能测试

性能检测是作为性能优化过程中的一环，他的目的通常是给后续优化工作提供指导方向，参考基线以及千户对比的依据。性能检测并不是一次性执行结束后就完成的工作，他会在检测，记录和改进的迭代过程中不断重复。来协助网站的性能优化不断接近期望的效果。

### 1. Lighthouse（灯塔）

```Lighthouse```是谷歌开发并开源的```web```性能测试工具，用于改进网络应用的质量，可以将其作为一个```Chrome```扩展程序运行，或从命令行运行。只需要为其提供一个需要审查的地址，```Lighthouse```就会对页面进行一连串的测试，生成一个有关页面性能的报告。

在浏览器的调试工具中默认就存在```lighthouse```选项，只需要切换至```lighthouse```，在右侧的选项区选中需要的选项。点击生成报告。

![屏幕快照 2021-06-16 14.22.33.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d85b452831ac46dea9b5a06b37a22659~tplv-k3u1fbpfcp-watermark.image)

可以看到淘宝的首屏时间是```0.6s```，可交互时间是```1.5s```，总阻塞时间是```10ms```。最大绘制时间是```1s```。通过这些指标就可以看到在哪方面存在性能瓶颈。

![屏幕快照 2021-06-16 14.26.33.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43aaa88418054be2b7baea4496ab53ce~tplv-k3u1fbpfcp-watermark.image)

在下方会对渲染进行拍照截图，如果空白页面较多也能体现网站白屏时间过长。下面还会给一些优化建议。比如某些资源过大，加载时间过长等，当然这些建议不并一定都是对的，只是一些建议。

![屏幕快照 2021-06-16 14.29.16.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c18243230994974bc9fe36775ef4a84~tplv-k3u1fbpfcp-watermark.image)

最后是测试环境信息，不能制作一种环境的测试，要多环境测试。

![屏幕快照 2021-06-16 14.32.06.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1087cfefaba456d80c71475f9561557~tplv-k3u1fbpfcp-watermark.image)

### 2. WebPageTest

在线```web```性能测试工具(```https://www.webpagetest.org```), 提供多地点测试。他只能测试已经发布了的网站。输入需要测试的网页地址，点击```start test```按钮就开始测试了，可以选择测试地理位置，测试的浏览器等。

![屏幕快照 2021-06-16 14.42.45.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c067390572d4f3db7f244bb5e6f8d86~tplv-k3u1fbpfcp-watermark.image)

![屏幕快照 2021-06-16 14.45.05.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e5a9cdaa0ec48c4a4b971ca6adbd261~tplv-k3u1fbpfcp-watermark.image)

这里会生成一份详细的测试数据，我这里没打开，打开再补图吧，尴尬...

## 6. Chrome DevTools

### 1. 浏览器的任务管理器

可以查看当前```Chrome```浏览器中，所有进程关于```GPU```，网络和内存空间的使用情况，这些进程包括当前打开的各个标签页，安装的各种扩展插件，以及```GPU```，网络，渲染等浏览器的默认进程，通过监控这些数据，可以定位可能存在内存泄露或网络资源加载异常的问题进程。

更多工具 ```->``` 任务管理器

![屏幕快照 2021-06-16 15.02.04.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb7d60f9ae94a7783b0a405a6c8cbb6~tplv-k3u1fbpfcp-watermark.image)

可以看到所有进行的进程，可以看到内存占用网络消耗。

### 2. Network网络分析

```Network```面板是一个常被用到的工具，通过它可以获取到网站所有资源的请求情况，包括加载时间，尺寸大小，优先级设置以及```HTTP```缓存等信息。可以帮助开发者发现可能由于未进行有效压缩而导致资源尺寸过大的问题，未配置缓存策略导致二次请求加载时间过长的问题。

![屏幕快照 2021-06-16 15.04.35.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/183ba56bd6424ca2ab6c172f2979742f~tplv-k3u1fbpfcp-watermark.image)

![屏幕快照 2021-06-16 15.08.47.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/039821a19dc0448b9ae3ce5a6f5113bd~tplv-k3u1fbpfcp-watermark.image)

![屏幕快照 2021-06-16 15.10.08.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/480bc72628c34504a5defed398311f8b~tplv-k3u1fbpfcp-watermark.image)

### 3. Coverage

监控并统计出网站应用运行过程中代码执行的覆盖率情况。

统计的对象是```JavaScript```脚本文件与```css```样式文件，统计结果主要包括文件的字节大小，执行过程中已覆盖的代码字节数，可视化的覆盖率条形图。

根据执行结果可以发现到底哪些尺寸较大的代码文件覆盖率较低，这就意味着这些代码文件中可能存在较多的无用代码。

```Ctrl + shift + p ```搜索 ```coverage``` 就会显示出来。

![屏幕快照 2021-06-16 15.18.59.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63bc8df8b2e744ccbcf974aebe376986~tplv-k3u1fbpfcp-watermark.image)

可以看到第一个文件有```58%```没有被使用到，第二个有```95.2%```没有使用到。

![屏幕快照 2021-06-16 15.21.02.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdf1b415e8764d779c45165500d6e20d~tplv-k3u1fbpfcp-watermark.image)

### 4. Memory 面板

主要用于分析内存占用情况，如果出现内存泄露，那么就可能带来网站崩溃的后果。

为了更细致和准确的监控应用网站当前的内存使用情况，```Chrome```浏览器提供```Memory```面板，可以快速生成当前的堆内存快照。

![屏幕快照 2021-06-16 16.25.26.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25bcc02135eb417e877b96e92fd6a211~tplv-k3u1fbpfcp-watermark.image)

结束后可以查看到内存占用大小，就可以对对应的模块进行优化。

![屏幕快照 2021-06-16 16.26.46.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c629358967640708ad087e849f93a61~tplv-k3u1fbpfcp-watermark.image)

### 5. Performance

使用```Performance```面板主要对网站应用的运行时性能表现进行检测和分析，包括页面的每秒帧数，```CPU```的消耗和各种请求花费的时间。

![2021616-163344.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b49337f55814f178728c4338ca0c001~tplv-k3u1fbpfcp-watermark.image)

点击开始后等待两三秒就可以停止了。

![屏幕快照 2021-06-16 16.35.58.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1070a5341a45434fb3dc6b48149392d5~tplv-k3u1fbpfcp-watermark.image)

这里面就可以统计出网站的信息。

![屏幕快照 2021-06-16 16.37.43.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc09177541e045399bebc3d4dd3670f2~tplv-k3u1fbpfcp-watermark.image)

### 6. FPS

另一个非常方便的工具是```FPS```计数，可以在页面运行时提供对```FPS```的实时估计。

```Ctrl + Shift + P``` 输入 ```fps``` 选择显示渲染。就会在浏览器中出现监控面板。

![屏幕快照 2021-06-16 16.43.01.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92ca36261144baa8e1ec22da3a96a7b~tplv-k3u1fbpfcp-watermark.image)

还可以使用性能监视器，这是一个事实的监视器。

```Ctrl + Shift + P``` 输入 ```monitor```

![屏幕快照 2021-06-16 16.46.24.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7886bdeb5fcb46bd86f5f87fb495670e~tplv-k3u1fbpfcp-watermark.image)

## 图片资源优化

jpeg 一种针对彩色照片而广泛使用的有损压缩图形格式。是一种栅格图形，常用文件扩展名为```jpg```，```jpeg```，```jpe```。在互联网上常被应用于存储和传输照片。不适合线条图形和文字，图标图形，因为他的压缩算法不支持这些类型的图形，并且不支持透明度。常用于色彩丰富的照片，彩色图大焦点图```banner```等结构不规则的图形。

png 便携式网络图形，是一种无损压缩的位图图形格式，支持索引、灰度、```RGB```三种颜色，以及```Alpha```通道等特性。他最初的设计是为了代替```GIF```,能够支持半透明和透明特性，最高支持```24```位彩色图形和```8```位灰度图像。不过由于是无损压缩所以文件体积太大。比较适合纯色，透明，线条绘图，图标以及颜色较少的需要半透明的图片。

GIF 位图图形文件格式，```8```位色重现真彩色的图像，采用```LZW```压缩算法进行编码。支持```256```色，仅支持完全透明和完全不透明，可以支持动图，不过每个像素只有```8```比特，不适合存储彩色图片。常用与动画和图标。

webp 是一种现代图像格式，可以提供无损压缩和有损压缩两种。可以同时办证一定程序上的图像质量和较小的体积，可以插入多帧，实现动画效果。支持透明度。采用```8```位压缩算法，无损的```webp```比```png```小```26%```，有损的```webp```比```jpeg```小```25-34%```，比```gif```有更好的动画。不过最多可以处理```256```色，不适合彩色图片。常用于图形和半透明图像。

### 1. 图片优化

对于```png```图片来说，可以使用```jdf-png-native```进行压缩, 他是```node-pngquant-native```工具的封装包，这个工具跨平台，压缩比高，而且压缩```png24```也非常的好。

```js
const pngquant = require('jdf-png-native');
const fs = require('fs');

fs.readFile('./in.png', (err, buffer) => {
    if (err) {
        throw err;
    }
    const resBuffer = pngquant.option({}).compress(buffer);
    fs.writeFile('./out.png', resBuffer), {
        flags:'wb'
    }, () => {})
})
```

压缩```jpg```可以使用```jpegtran```这个工具，他也是一个```node```工具。使用方法比较简单，直接使用命令即可。大概压缩```10%```的占比。

```s
jpegtran -copy node -optimize-outfile out.jpg in.jpg
```

对于```gif```文件来说可以使用```gifsicle```工具，他是通过改变每帧比例，减小```gif```文件大小，同时可以使用透明来达到更小的文件体积。是一个公认的解决方案。可以去```http://www.lcdf.org/gifsicle/```中去安装。使用方式同样也是命令行方式。

```s
gifsicle --optimize=3 --crop-transparency -o out.gif in.gif
```

这里的优化级别不要小于```2```，```1```的话代表不压缩。压缩后基本不失帧。

还有一种压缩方式是图片可以根据网络环境来展示不同尺寸和像素的图片，通过在```url```后缀加不同参数来实现。比如下面的地址,```430```可以修改为```800```来获得不同体积的图片。

```https://img.alicdn.com/imgextra/i1/2616970884/O1CN01x6HnoK1IOuj5IosXO_!!2616970884.jpg_430x430q90.jpg```

### 2. 响应式图片

响应式图片是我们可以在用户不同的窗口大小还有设备像素的情况下来展示不同大小的图片，可以用以下三种方式来实现, 第一种是可以使用```js```来绑定事件检测窗口大小，以此来设置图片的大小。第二种方式就是```css```的媒体查询。

```css
@media screen and (max-width:640) {
    my_image { width:640px; }
}
```

第三种可以使用```html5```的```srcset```来设置，他会根据设备的像素比来自动选择需要的图片。而且不支持```srcset```的浏览器也可以正常展示```src```的属性。

```html
<img srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x" src="img-960w.jpg" alt="img" />
```

### 3. 逐步加载图片的方式

其实就是延迟加载，在真实的图片加载出来之前，可以使用一张公共的图片，一般是公司的```logo```，先将布局撑起来，然后再换成真实的图片。

```lqip```这个工具可以将真实的图片虚化，转换为很小的```base64```编码。这样我们可以先使用```base64```加载虚化的图片。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install lqip
```

```js
const lqip = require('lqip');
const file = './in.png';
// image
lqip,base64(file).then(res => {
    console.log(res); // 输出base64
})
// color
lqip.paletter(file).then(res => {
    console.log(res); // 图片颜色值
})
```

也可以使用低质量图片占位符, 他是基于SVG的图像占位符实现的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install sqip
```

```js
const sqip = require('sqip');

const result = sqip({
    filename:'./in.png',
    numberOfPrimitives:10 // 效果值
});

console.log(result.final_svg); // 输出svg格式
```

相比```lqip```来说```sqip```效果会好很多，而且可以设置不同的大小。

### 4. 其他方式

可以使用```web font```来代替图片，比如说小图标等业务小图片。

也可以用```dataurl```的方式，也就是前面的```base64```的方式来代替图片，这样用户就不需要发送```http```请求了。

也可以采用雪碧图将多个小图片合成一个大图，这样也会节省很多的图片请求。

### 5. 图片服务器自动优化

图片服务器优化是指可以在图片```url```连接上增加不同特殊参数，让服务器自动生成不同格式，大小，质量的图片。

比如说可以对图片做一些裁剪，裁剪成我们需要的图片，也可以支持不同格式的转换，比如说```jpg```，```gif```，```png```，```webp```等也可以设置图片的压缩比。

也可以对图片添加一些水印，高斯模糊，重心处理等还可以增加一些AI的能力，比如说用户上传的图片是否涉黄。还可以通过智能抠图，智能排版，智能配色智能合成等功能完善图片。

## HTML的优化方法

### 1. 精简html代码

可以减少```html```的嵌套也就是层级关系尽量减小，也可以减小```DOM```节点数也就是尽量压缩优化```DOM```的节点数, 让浏览器渲染的```DOM```节点数最少。

减少一些无语义的代码，比如说空标签清浮动那种代码```<div class="clear"></div>```能不用最好不要用。

建议连接中删除```http```或者```https```，因为一般链接的协议头和页面的协议头都是一致的，写他们多了```4-5```个字符其实是没有什么意义的。而且可以减少代码体积。

也可以删除多余的空格，换行符，缩进和不必要的注释，一般会用压缩工具来处理这个过程。可以省略一些标签和属性。使用相对路径的```url```，最大范围的减少字节数。

### 2. 文件位置

```css```文件链接尽量放在页面头部，```css```加载不会阻塞```DOM Tree```解析，但是会阻塞```DOM Tree```渲染，也会阻塞后面```js```执行。也就是说```DOM Tree```在渲染前就要解析好```CSS```，从而减少浏览器重排文档的次数。而且```css```放在页面底部会导致页面白屏时间变长。

```js```文件一般放在页面底部，这是防止```js```的加载和解析阻塞页面元素的正常渲染。

### 3. 用户体验

设置```favicon.ico```, 如果不设置控制台会报错，而且用户访问的时候地址栏也是空的，不利于品牌记忆。

增加首屏必要的```css```和```js```，一般页面需要在等待所有的依赖加载完成才会展示，这样就会导致页面存在空白。永祥用户体验，可以增加背景图或者```loading```或者骨架屏，比空白页好很多。

## CSS优化细则

### 1. 提升css渲染性能

谨慎使用一些```expensive```的属性，比如```nth-child```伪类或者```position:fixed```定位，因为这些比较消耗浏览器的渲染性能。

尽量减少一些样式层级的级数，比如，```div ul li span i { color:red}```, 其实我们可以给i标签设置```class```，直接书写样式。

避免使用占用过多```cpu```和内存的属性，比如```text-indent```不要设置太大的值。

尽量避免使用耗电量大的属性，比较占用```GPU```, 比如```transfrom```是，```transitions, opacity```。

合适的使用```css```选择器, 尽量避免使用通配符，避免使用```css```表达式。```color:expression((new Date()).getHours() % 2 ? "#fff" :"#000")```。

避免类正则的属性选择器。```*=```，```|=```，```^=```，```$=```，使用外链的```css```，可以单独形成文件放在```cdn```，使用缓存形式加载。避免使用```@import```因为他的加载会阻塞进程，需要加载完毕才会向下执行。

精简```css```代码，使用缩写的语句，比如```margin-top```可以写在```margin```中，再者如果值为```0```能删除就删除，删除不必要的单位值，删除过多的分号，删除空格和注释。尽量减小样式表的体积。其实这些都可以使用压缩工具来处理，会方便很多。

### 2. 合理使用web fonts

可以将字体文件部署到```cdn```上，加快用户端的加载速度，也可以将字体以```base64```的形式保存在```css```中，并通过```localStorage```进行缓存。一些谷歌字体库应该使用国内托管服务不要直接使用源地址。

### 3. css动画优化

避免同时动画，也就是说用户访问的屏幕区间里面不要有过多的动画，动画太多会干扰用户正常浏览网站，而且动画多也影响浏览器的性能。

延迟动画的初始化，可以让其它```css```先渲染，让动画延迟，比如说```0.5```或```1```。

可以借助```svg```去展示动画，样式放在```css```里面控制。

## JavaScript优化

首先我们是当需要的时候才去优化，不是为了优化而优化，一般的优化是在某一个时间点进行的，而且优化也需要考虑可维护性这是要结合团队的研发水平和代码的规范。

### 1. 提升js文件的加载性能

这个基本每个人都知道，就是```css```文件放在head标签中，```js```文件放在```body```结尾的地方。这个是```js```的加载不要影响```html```的渲染。

### 2. 变量和函数方面的优化

尽量使用```id```选择器，因为```id```选择器在查询效果上效率最快。

避免使用```eval```，这个方法比较消耗能行。

```js```函数尽可能保持简洁，不要把太多内容写在一个函数中。也建议使用事件的节流函数。事件委托等等。

### 3. js动画

尽量避免添加大量的```js```动画，```css3```动画和```canvas```动画都比```js```动画性能好。

使用```requestAnimationFrame```来代替```setTimeout```和```setInterval```，因为```requestAnimationFrame```可以在正确的时间进行渲染，```setTimout```和```setInterval```无法保证渲染时机。不要在定时器里面绑定事件。

### 4. 使用逻辑缓存

缓存```dom```对象，也就是用一个变量来存储```do```m对象，不要每次使用都查询。

缓存列表长度，也就是说用变量存储```dom```元素的个数，而不是每次都重新计算。

比如百度```M```站，会把页面的```css```和```js```放在本地存储里面，这样后面再加载的时候就直接从本地存储里面取，实现秒考的效果。不过本地存储空间有限，要谨慎使用。

### 5. WebWorker

可以将一些纯计算的工作迁移到```Web Worker```上处理，他为```JavaScript```的执行提供了多线程环境，主线程通过创建出```Worker```子线程，可以分担一部分自己的任务执行压力，在```Worker```子线程上执行的任务不会干扰主线程，待其上的任务执行完成后，会把结果返回给主线程，这样的好处是让主线程可以更专注的处理```UI```交互，保证页面的使用体验流程。

```js
// 创建Worker线程
const worker = new Worker('work.js')
// 主线程中关闭
worker.terminate();

// 子线程中关闭
self.close();
```

### 6. 节流和防抖

```js
function throttle(fn，delay) {
    let lastTime;
    let timer;
    delay || (delay = 300);
    rteurn function (arguments) {
        let context = this;
        let args = arguments;
        let nowTime = +new Date();
        if (lastTime && nowTime < lastTime + delay) {
            clearTimeout(timer);
            timer = setTimeout(function() { // 到达执行时间
                lastTime = nowTime;
                fn.apply(context，args);
            }，delay)
        } else { // 当前距离上次执行的时间大于等于设置时间，立即执行
            lastTime = nowTime;
            fn.apply(context，args)
        }
    }
}
```

```js
function debounce(fun，delay) {
    return function (arguments) {
        let context = this;
        let args = arguments;
        clearTimeout(fun.id)
        fun.id = setTimeout(function() {
            fun.call(context，args)
        }，delay)
    }
}
```

### 7. 慎用全局变量

```js
(function() {
    let str = '';
    for (let i = 0; i < 1000; i++) {
        str += i;
    }
})()
```

这个时候就相当是用两份不同的代码去完成了一个相同的效果。接下来把他们放在```JavaScriptperf```当中大量执行，从而得出谁的执行效率更高。

在```JavaScriptperf```中分别贴入这两段代码，运行脚本得出最终的性能结果。执行完成以后可以发现，采用全局变量和采用局部变量之间的差距是非常大的。

### 8. 通过原型对象添加附加方法

把某些调用频繁的方法添加在原型对象上，而不需要放在构造函数内部。比较一下两种不同的实现方式的性能。

```js
var fn2 = function() {}
fn2.prototype.foo = function() {
    console.log(11111);
}

let f2 = new fn2();
```

### 9. 选择最优的循环方法

```foreach```效率最高，```for...in...```效率最低。

### 10. 文档碎片优化节点添加

```DOM```操作是非常消耗性能的，特别是创建新的节点，将它添加至界面中时，这个过程一般都会伴随着回流和重绘。这两个操作对性能的消耗又是比较大的。

```js
// 使用优化
const fragEle = document.createDocumentFragment();
for (var i = 0; i < 10; i++) {
    var oP = document.createElement('p');
    oP.innerHTML = i;
    fragEle.appendChild(oP);
}
document.body.appendChild(fragEle);
```

### 11. 克隆优化节点操作

页面渲染完成之后页面中存在很多```p```标签，当要新增节点的时候，可以找到一个与新增节点类似的已经存在于页面中的节点，通过克隆的方式添加到界面当中。这样优化的内容是本身已经具有的样式和属性就不需要后续执行添加了，这就是所谓的优化。

```html
<body>
    <p id="box1">old</p>
    <script>
        // 克隆方式
        var oldP = document.getElementById('box1');
        for (var i = 0; i < 10; i++) {
            var newP = oldp.cloneNode(false);
            newP.innerHTML = i;
            document.body.appendChild(newP);
        }
    </script>
</body>
```

### 12. 直接量替换newObject

定义对象和数组的时候，有两种不同的形式，可以使用```new```的方式获取相应的数据，也可以直接采用字面量。

```js
// 字面量方式
var a = [1, 2, 3];

// 实例化方式
var a1 = new Array(3)
a1[0] = 1;
a1[1] = 2;
a1[2] = 3;
```

## 减少页面回流和重绘

### 1. css

避免过多的样式嵌套，最好可以快速的定位到元素。

避免使用```css```表达式，```css```表达式会在```css```绘制的过程中都会执行，会增加重排和回流的次数。

可以使用绝对定位让动画元素脱离文档流。

避免使用```table```布局他会引起浏览器的多次重绘，也不要使用```float```布局。

图片最好设置好设置```width```和```height```，这样图片在加载之后布局就可以确定了。

简化浏览器不必要额任务，使用```viewport```设置屏幕缩放级别。

避免频繁设置样式，将多个样式操作合并修改,一次性的更新。

### 2. js

为了减少回流发生次数，应该避免频繁操作``DOM``，可以合并多次对```DOM```的修改，一次性批量处理。

控制绘制过程和绘制区域，绘制过程开销比较大的属性设置应当避免使用。

## 简化DOM操作

众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量```DOM```元素，想想一下，从一个上万节点的```DOM```树上，使用```querySelectorAll```或```getElementByTagName```方法查找某一个节点，是非常耗时的，另外元素绑定事件时，事件冒泡和事件捕获的执行也会相对耗时。所以一般我们应该合理的不熟业务逻辑，```DOM```节点过多时应该延迟即将呈现的```DOM```内容。

对```DOM```的操作最好统一处理后再统一插入到```DOM Tree```中。可以使用```fragment```对```DOM```和样式设置好再统一放到页面中去。

目前比较流行的框架，比如```Angular```，```React```和```Vue```都是使用```虚拟DOM```技术，通过```diff```算法简化和减少```DOM```操作。

## 静态文件压缩工具

html-minifier:压缩```html```
clean-css:```css```的压缩工具
uglify-js:```js```文件的压缩工具

## 浏览器渲染过程

首先浏览器会解析```HTML```生成```DOM Tree```，然后解析```CSS```生成```CSSOM Tree```。接着```JS```会通过```DOM Api```和```CSSOM Api```来操作```DOM Tree```和```CSS Rule Tree```将```DOM Tree```和```CSSOM Tree```合成一颗渲染树```Rend