## 事件循环

最早 javaScript 这门语言是一门运行在浏览器端的脚本语言，目的是实现页面上的动态交互。核心就是dom 操作，这也决定了他必须使用单线程模型，否则就会出现很复杂的线程同步问题。设想一下，假定有多个线程同时操作 dom 元素，就无法明确该以哪一个线程的工作结果为准。

所以从一开始 javaScript 就被设计成了单线程模式工作，这也就成为了这门语言最为核心的特性之一。

可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，平时在开发中，大家也可以在报错中找到执行栈的痕迹。当使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。

当执行 JS 代码的时候其实就是往执行栈中放入函数，遇到异步代码的时候会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。

不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。

首先 JavaScript 代码从上到下执行每遇到定时器等宏任务会将任务放在宏任务队列中，遇到 Promise.then 等微任务会将任务放入到微任务队列中。等到主执行栈中的代码执行完毕，会清空微任务队列，先加入的先执行后加入的后执行，然后再去检查宏任务队列，将可执行的宏任务拿到执行栈中执行，每次只取出一个宏任务，执行完毕再次清空微任务队列，清空完毕再去检查宏任务队列，以此类推。

```js
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}

async function async2() {
  console.log('async2')
}

console.log('script start')
setTimeout(function() {
  console.log('setTimeout')
}, 0)

async1(); 

new Promise( function( resolve ) {
 console.log('promise1')
 resolve();
}).then( function() {
 console.log('promise2')
})
```

首先前两个函数同样是创建了两个函数，然后console.log('script start')在执行时会打印script start。

接着 setTimeout 创建了一个可以被执行的宏任务。

async1()调用了函数 async1 ，首先打印async1 start，然后await async2()，这相当于new Promise传入的函数，会立即执行，所以打印 async2 。

await下面的代码console.log('async1 end')会被作为微任务放入到微任务队列中。因为 async2 已经执行完了，所以这个微任务也是一个可以被执行的微任务。

这样 async1 函数执行完毕，继续向下new Promise会打印 promise1 ，并且修改 Promise 状态，再次创建一个可以被执行的微任务。

至此执行栈执行完毕，此时宏任务队里存在一个 setTimeout 任务，微任务队列存在async1 end和 promise2 的两个微任务。

清空微任务队列，根据队列先进先出的原则，先打印async1 end再打印 promise2 。最后执行宏任务队列，打印 setTimeout 。

所以输出结果为 script start -> async1 start -> async2 -> promise1 -> async1 end -> promise2 -> setTimeout

微任务包括 process.nextTick ，promise ，MutationObserver。

宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。

一般微任务都是由宏任务产生的，一个宏任务产生的微任务会在这个宏任务执行完执行产生的微任务，然后再执行下一个宏任务。

Node 中的 Event Loop 和浏览器中的是完全不相同的东西。

览器中存在两个任务队列，一个是宏任务一个是微任务。但是在 NodeJS 中一共存在六个事件队列，timers，pending callbacks，idle prepare，poll，check，close callbacks。每一个队列里面存放的都是回调函数 callback 。

这六个队列是按顺序执行的。每个队列负责存储不同的任务。

timer里面存在的是 setTimeout 与 setInterval 的回调函数

pending callback是执行操作系统的回调，例如 tcp ,udp。

idle 和 prepare只在系统内部进行使用。一般开发者用不到

poll执行与 IO 相关的回调操作

check中存放 setImmediate 中的回调。

close callbacks执行 close 事件的回调。

在 Node 中代码从上到下同步执行，在执行过程中会将不同的任务添加到相应的队列中，比如说 setTimeout 就会放在 timers 中, 如果遇到文件读写就放在 poll 里面，等到整个同步代码执行完毕之后就会去执行满足条件的微任务。可以假想有一个队列用于存放微任务，这个队列和前面的六种没有任何关系。

当同步代码执行完成之后会去执行满足条件的微任务，一旦所有的微任务执行完毕就会按照上面列出的顺序去执行队列当中满足条件的宏任务。

首先会执行 timers 当中满足条件的宏任务，当他将 timers 中满足的任务执行完成之后就会去执行队列的切换，在切换之前会先去清空微任务列表中的微任务。

所以微任务执行是有两个时机的，第一个时机是所有的同步代码执行完毕，第二个时机队列切换前。

注意在微任务中 nextTick 的执行优先级要高于 Promise ，这个只能死记了。Node 中的 process.nextTick 其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。

```js
const fs = require('fs');

fs.readFile('./a.txt', () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)

    setImmediate(() => {
        console.log('immdieate');
    })
})
```

这种情况就会一直先输出 immdieate 后输出 timeout ，这是因为，代码执行的时候会在 timers 里面加入 timeout , 在 poll 中加入 fs 的回调，在 check 中加入 immdieate 。fs的回调执行结束之后实在 poll 队列，队列切换的时候首先会去看微任务，但是这里没有微任务就会继续向下，下面就是 check 队列而不是 timers 队列，所以 poll 清空之后会切换到 check 队列，执行 immdieate 回调。

## 手写call, apply, bind

```js
Function.proptotype.call = function(_this, props) {
  const fn = this;
  if (!_this) {
    _this = Object.create(null);
  }
  _this.fn = fn;
  const ret = _this.fn(...props);
  delete _this.fn;
  return ret;
}

Function.proptotype.call = function(_this, ...props) {
  const fn = this;
  if (!_this) {
    _this = Object.create(null);
  }
  _this.fn = fn;
  const ret = _this.fn(...props);
  delete _this.fn;
  return ret;
}
// bind不受new影响
Function.prototype.bind = function(_this, ...props1) {
  const fn = this;
  return function F(...props2) {
    return this instanceof F ? new fn(...props1, ...props2) : fn.call(_this, ...props1, ...props2);
  }
}
```

## new 关键字原理

在调用 new 的过程中会发生以上四件事情：

- 新生成了一个对象
- 链接到原型
- 绑定 this
- 返回新对象

```js
function myNew(construct, ...props) {
  const o = Object.create(construct.prototype);
  const ret = construct.call(o, ...props);
  return ret instanceof Object ? ret : o;
}
```

## instanceof原理

instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。

首先获取类型的原型，然后获得对象的原型，一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null。
```js
function instanceOf(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}
```

## 为什么 0.1 + 0.