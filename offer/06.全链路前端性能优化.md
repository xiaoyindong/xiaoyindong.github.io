通常来讲前端性能优化是指从用户开始访问我们的网站到整个页面完整的展现出来的过程中，通过各种优化策略和优化方法让页面加载的更快，让用户的操作响应更及时，给用户更好的使用体验。这里介绍的是前端性能优化知识的解决方案，从静态资源优化开始入手，从表象深入体系化的讲解页面渲染架构，掌握高效的技术方案。

页面性能关乎到用户的留存，网站的转换率，用户体验和网站的传播，甚至影响搜索排名遭到用户投诉，当然也会影响开发的效率。本文并非细节的讲述如何实现性能优化，而是从各个方面介绍性能优化的方式方法，并且不仅限于H5，因为当今的前端也不仅仅只有H5。

## 性能指标

性能是相对的，对于一个用户而言在不同的网络环境下访问页面的速度可能是不同的，即使相同的网站在懒加载的情况下也会显得快。

在讨论性能的时候精确地，可量化的指标是很重要的。但是仅仅因为一个度量标准是基于客观准备并且可以定量的度量的，并不一定意味这些度量是有用的。对于```Web```开发人员来说，如何恒量一个```Web```页面的性能一直都是一个难题。

最初，开发人员使用```Time to To Byte```。```DomContentLoaded```和```Load```这些衡量文档加载进度的指标，但他们不能直接反应用户视觉体验。

为了恒量用户视觉体验，Web标准中定义了一些性能指标。这些性能指标被各大浏览器标准化实现，例如```First Paint```和```First Contentful Paint```。

还有一些由Web孵化器社区组提出的性能指标，如```Largest Contentful Paint```、```Time to Interactive```、```First Input Delay```、```First CPU Idle```。

另外还有```Google```提出的```First Meaningful Paint```、```Speed Index```。百度提出的```First Screen Paint```。

这些指标之间并不是毫无关联，而是在以用户为中心的目标中不断演进出来的，有的已经不再建议使用，有的被各种测试工具实现，有的则可以作为通用标准可用于生产环境测量的API。

### 1. RAIL性能模型

```RAIL```是```Response```，```Animation```，```Idle```和```Load```的首字母缩写，是一种由```Google Chrome```团队于```2015年```提出的性能模型，用于提升浏览器的用户体验和性能。

```RAIL```模型的理念是以用户为中心，最终目标并不是让你的网站在任何特定设备上都能运行很快，而是使用户满意。

```Response```应该尽可能快速的响应用户的操作，应在在```100ms```以内响应用户输入。

```Animation```在展示动画的时候，每一帧应该以```16ms```进行渲染，这样可以保持动画效果的一致性，并且避免卡顿。

```Idle```当使用```js```主线程的时候，应该把任务划分到执行时间小于```50ms```的片段中去，这样可以释放线程以进行用户交互。```50ms```为单位是为了保证用户在发生操作的```100ms```内做出响应。

要使网站响应迅速，动画流畅，通常都需要较长的处理时间，但以用户为中心来看待性能问题，就会发现并非所有工作都需要在响应和加载阶段完成，完全可以利用浏览器的空闲时间处理可延迟的任务，只要让用户感受不到延迟即可。利用空闲时间处理延迟可减少预加载的数据大小，以保证网站或应用快速完成加载。

```Load```应该在小于```1s```的时间内加载完成你的网站，并可以进行用户交互。根据网络条件和硬件的不同，用户对性能延迟的理解也有所不同，在```3G```网络需要花费更多的时间，```5s```是一个更现实的目标。

###  2. FCP (First Contentful Paint)

首次内容绘制，浏览器首次绘制来自```DOM```的内容的时间，内容必须包括文本，图片，非白色的```canvas```或```svg```，也包括带有正在加载中的```web```字体文本。这是用户第一次看到的内容。

| FCP时间(秒) | 颜色编码 | FPC分数 |
| -- | -- | -- |
| 0 - 2 | 绿色(快) | 75 - 100 |
| 2 - 4 | 橙色(中等) | 50 - 74 |
| 超过4 | 红色(慢) | 0 - 49 |

### 3. LCP (Largest Contentful Paint)

最大内容绘制，可视区域中最大的内容元素呈现到屏幕上的时间，用以估算页面的主要内容对用户的可见时间。```img```图片，```video```元素的封面，通过```url```加载到的北京，文本节点等，为了提供更好的用户体验，网站应该在```2.5s```以内或者更短的时间最大内容绘制。

| LCP时间(秒) | 颜色编码 |
| -- | -- |
| 0 - 2.5 | 绿色(快) |
| 2.5 - 4 | 橙色(中等) |
| 超过4 | 红色(慢) |

### 4. FID (First Input Delay)

首次输入延迟，从用户第一次与页面进行交互到浏览器实际能够响应该交互的时间，输入延迟是因为浏览器的主线程正忙于做其他事情，所以不能响应用户，发生这种情况的一个常见原因是浏览器正忙于解析和执行应用程序加载的大量计算的```JavaScript```。

| FID时间(毫秒) | 颜色编码 |
| -- | -- |
| 0 - 100 | 绿色(快) |
| 100 - 300 | 橙色(中等) |
| 超过300 | 红色(慢) |

### 5. TTI (Time to Interactive)

网页第一次完全达到可交互状态的时间点，浏览器已经可以持续的响应用户的输入，完全达到可交互的状态的时间是在最后一个长任务完成的时间，并且在随后的```5s```内网络和主线程是空闲的。从定义上来看，中文名称叫持续可交互时间或可流畅交互时间更合适。

| TTI时间(秒) | 颜色编码 |
| -- | -- |
| 0 - 3.8 | 绿色(快) |
| 3.9 - 7.3 | 橙色(中等) |
| 超过7.3 | 红色(慢) |

### 6. TBT (Total Block Time)

总阻塞时间，度量了```FCP```和```TTI```之间的总时间，在该时间范围内，主线程被阻塞足够长的时间以防止输入响应。只要存在长任务，该主线程就会被视为阻塞，该任务在主线程上运行超过```50```毫秒。

线程阻塞是因为浏览器无法中断正在进行的任务，因此如果用户确实在较长的任务中间与页面进行交互，则浏览器必须等待任务完成才能响应。

| TBT时间(毫秒) | 颜色编码 |
| -- | -- |
| 0 - 300 | 绿色(快) |
| 300 - 600 | 橙色(中等) |
| 超过600 | 红色(慢) |

### 7. CLS (Cumulative Layout Shift)

累计布局位移，```CLS```会测量在页面整个生命周期中发生的每个意外的布局移位的所有单独布局移位分数的总和，他是一种保证页面的视觉稳定性从而提升用户体验的指标方案。

用人话来说就是当点击页面中的某个元素的时候，突然布局变了，手指点到了其它位置。比如想点击页面的链接，突然出现了一个```banner```。这种情况可能是因为尺寸未知的图像或者视频。

| CLS时间(毫秒) | 颜色编码 |
| -- | -- |
| 0 - 0.1 | 绿色(快) |
| 0.1 - 0.25 | 橙色(中等) |
| 超过0.25 | 红色(慢) |

Web Vitals是谷歌指定的```web```性能指标标准，谷歌认为之前的标准太复杂，指标太多了，在```2020```年重新进行了梳理，简化到了三个。加载性能```LCP```，交互性```FID```，视觉稳定性```CLS```。只需要做好这三个，网站的性能基本上就可以了。测量```Web Vitals```的工具有很多，比如```Lighthouse```，```web-vitals```，浏览器插件```web vitals```。

### 1. Web-Vitals

```js
// npm install web-vitals -g

import { getLCP, getFID, getCLS } from 'web-vitals';

getCLS(conole.log)
getFID(conole.log)
getCLS(conole.log)
```

### 2. 浏览器插件

谷歌浏览器可以直接在插件市场中查找并且安装```web vitals```。安装完成之后浏览器的右上角会多出插件标志，点击就会显示页面的性能指标。

## 性能测试

性能检测是作为性能优化过程中的一环，他的目的通常是给后续优化工作提供指导方向，参考基线以及千户对比的依据。性能检测并不是一次性执行结束后就完成的工作，他会在检测，记录和改进的迭代过程中不断重复。来协助网站的性能优化不断接近期望的效果。

### 1. Lighthouse（灯塔）

```Lighthouse```是谷歌开发并开源的```web```性能测试工具，用于改进网络应用的质量，可以将其作为一个```Chrome```扩展程序运行，或从命令行运行。只需要为其提供一个需要审查的地址，```Lighthouse```就会对页面进行一连串的测试，生成一个有关页面性能的报告。

在浏览器的调试工具中默认就存在```lighthouse```选项，只需要切换至```lighthouse```，在右侧的选项区选中需要的选项。点击生成报告。

![屏幕快照 2021-06-16 14.22.33.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d85b452831ac46dea9b5a06b37a22659~tplv-k3u1fbpfcp-watermark.image)

可以看到淘宝的首屏时间是```0.6s```，可交互时间是```1.5s```，总阻塞时间是```10ms```。最大绘制时间是```1s```。通过这些指标就可以看到在哪方面存在性能瓶颈。

![屏幕快照 2021-06-16 14.26.33.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43aaa88418054be2b7baea4496ab53ce~tplv-k3u1fbpfcp-watermark.image)

在下方会对渲染进行拍照截图，如果空白页面较多也能体现网站白屏时间过长。下面还会给一些优化建议。比如某些资源过大，加载时间过长等，当然这些建议不并一定都是对的，只是一些建议。

![屏幕快照 2021-06-16 14.29.16.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c18243230994974bc9fe36775ef4a84~tplv-k3u1fbpfcp-watermark.image)

最后是测试环境信息，不能制作一种环境的测试，要多环境测试。

![屏幕快照 2021-06-16 14.32.06.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1087cfefaba456d80c71475f9561557~tplv-k3u1fbpfcp-watermark.image)

### 2. WebPageTest

在线```web```性能测试工具(```https://www.webpagetest.org```), 提供多地点测试。他只能测试已经发布了的网站。输入需要测试的网页地址，点击```start test```按钮就开始测试了，可以选择测试地理位置，测试的浏览器等。

![屏幕快照 2021-06-16 14.42.45.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c067390572d4f3db7f244bb5e6f8d86~tplv-k3u1fbpfcp-watermark.image)

![屏幕快照 2021-06-16 14.45.05.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e5a9cdaa0ec48c4a4b971ca6adbd261~tplv-k3u1fbpfcp-watermark.image)

这里会生成一份详细的测试数据，我这里没打开，打开再补图吧，尴尬...

## 6. Chrome DevTools

### 1. 浏览器的任务管理器

可以查看当前```Chrome```浏览器中，所有进程关于```GPU```，网络和内存空间的使用情况，这些进程包括当前打开的各个标签页，安装的各种扩展插件，以及```GPU```，网络，渲染等浏览器的默认进程，通过监控这些数据，可以定位可能存在内存泄露或网络资源加载异常的问题进程。

更多工具 ```->``` 任务管理器

![屏幕快照 2021-06-16 15.02.04.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb7d60f9ae94a7783b0a405a6c8cbb6~tplv-k3u1fbpfcp-watermark.image)

可以看到所有进行的进程，可以看到内存占用网络消耗。

### 2. Network网络分析

```Network```面板是一个常被用到的工具，通过它可以获取到网站所有资源的请求情况，包括加载时间，尺寸大小，优先级设置以及```HTTP```缓存等信息。可以帮助开发者发现可能由于未进行有效压缩而导致资源尺寸过大的问题，未配置缓存策略导致二次请求加载时间过长的问题。

![屏幕快照 2021-06-16 15.04.35.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/183ba56bd6424ca2ab6c172f2979742f~tplv-k3u1fbpfcp-watermark.image)

![屏幕快照 2021-06-16 15.08.47.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/039821a19dc0448b9ae3ce5a6f5113bd~tplv-k3u1fbpfcp-watermark.image)

![屏幕快照 2021-06-16 15.10.08.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/480bc72628c34504a5defed398311f8b~tplv-k3u1fbpfcp-watermark.image)

### 3. Coverage

监控并统计出网站应用运行过程中代码执行的覆盖率情况。

统计的对象是```JavaScript```脚本文件与```css```样式文件，统计结果主要包括文件的字节大小，执行过程中已覆盖的代码字节数，可视化的覆盖率条形图。

根据执行结果可以发现到底哪些尺寸较大的代码文件覆盖率较低，这就意味着这些代码文件中可能存在较多的无用代码。

```Ctrl + shift + p ```搜索 ```coverage``` 就会显示出来。

![屏幕快照 2021-06-16 15.18.59.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63bc8df8b2e744ccbcf974aebe376986~tplv-k3u1fbpfcp-watermark.image)

可以看到第一个文件有```58%```没有被使用到，第二个有```95.2%```没有使用到。

![屏幕快照 2021-06-16 15.21.02.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdf1b415e8764d779c45165500d6e20d~tplv-k3u1fbpfcp-watermark.image)

### 4. Memory 面板

主要用于分析内存占用情况，如果出现内存泄露，那么就可能带来网站崩溃的后果。

为了更细致和准确的监控应用网站当前的内存使用情况，```Chrome```浏览器提供```Memory```面板，可以快速生成当前的堆内存快照。

![屏幕快照 2021-06-16 16.25.26.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25bcc02135eb417e877b96e92fd6a211~tplv-k3u1fbpfcp-watermark.image)

结束后可以查看到内存占用大小，就可以对对应的模块进行优化。

![屏幕快照 2021-06-16 16.26.46.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c629358967640708ad087e849f93a61~tplv-k3u1fbpfcp-watermark.image)

### 5. Performance

使用```Performance```面板主要对网站应用的运行时性能表现进行检测和分析，包括页面的每秒帧数，```CPU```的消耗和各种请求花费的时间。

![2021616-163344.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b49337f55814f178728c4338ca0c001~tplv-k3u1fbpfcp-watermark.image)

点击开始后等待两三秒就可以停止了。

![屏幕快照 2021-06-16 16.35.58.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1070a5341a45434fb3dc6b48149392d5~tplv-k3u1fbpfcp-watermark.image)

这里面就可以统计出网站的信息。

![屏幕快照 2021-06-16 16.37.43.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc09177541e045399bebc3d4dd3670f2~tplv-k3u1fbpfcp-watermark.image)

### 6. FPS

另一个非常方便的工具是```FPS```计数，可以在页面运行时提供对```FPS```的实时估计。

```Ctrl + Shift + P``` 输入 ```fps``` 选择显示渲染。就会在浏览器中出现监控面板。

![屏幕快照 2021-06-16 16.43.01.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92ca36261144baa8e1ec22da3a96a7b~tplv-k3u1fbpfcp-watermark.image)

还可以使用性能监视器，这是一个事实的监视器。

```Ctrl + Shift + P``` 输入 ```monitor```

![屏幕快照 2021-06-16 16.46.24.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7886bdeb5fcb46bd86f5f87fb495670e~tplv-k3u1fbpfcp-watermark.image)

## 图片资源优化

jpeg 一种针对彩色照片而广泛使用的有损压缩图形格式。是一种栅格图形，常用文件扩展名为```jpg```，```jpeg```，```jpe```。在互联网上常被应用于存储和传输照片。不适合线条图形和文字，图标图形，因为他的压缩算法不支持这些类型的图形，并且不支持透明度。常用于色彩丰富的照片，彩色图大焦点图```banner```等结构不规则的图形。

png 便携式网络图形，是一种无损压缩的位图图形格式，支持索引、灰度、```RGB```三种颜色，以及```Alpha```通道等特性。他最初的设计是为了代替```GIF```,能够支持半透明和透明特性，最高支持```24```位彩色图形和```8```位灰度图像。不过由于是无损压缩所以文件体积太大。比较适合纯色，透明，线条绘图，图标以及颜色较少的需要半透明的图片。

GIF 位图图形文件格式，```8```位色重现真彩色的图像，采用```LZW```压缩算法进行编码。支持```256```色，仅支持完全透明和完全不透明，可以支持动图，不过每个像素只有```8```比特，不适合存储彩色图片。常用与动画和图标。

webp 是一种现代图像格式，可以提供无损压缩和有损压缩两种。可以同时办证一定程序上的图像质量和较小的体积，可以插入多帧，实现动画效果。支持透明度。采用```8```位压缩算法，无损的```webp```比```png```小```26%```，有损的```webp```比```jpeg```小```25-34%```，比```gif```有更好的动画。不过最多可以处理```256```色，不适合彩色图片。常用于图形和半透明图像。

### 1. 图片优化

对于```png```图片来说，可以使用```jdf-png-native```进行压缩, 他是```node-pngquant-native```工具的封装包，这个工具跨平台，压缩比高，而且压缩```png24```也非常的好。

```js
const pngquant = require('jdf-png-native');
const fs = require('fs');

fs.readFile('./in.png', (err, buffer) => {
    if (err) {
        throw err;
    }
    const resBuffer = pngquant.option({}).compress(buffer);
    fs.writeFile('./out.png', resBuffer), {
        flags:'wb'
    }, () => {})
})
```

压缩```jpg```可以使用```jpegtran```这个工具，他也是一个```node```工具。使用方法比较简单，直接使用命令即可。大概压缩```10%```的占比。

```s
jpegtran -copy node -optimize-outfile out.jpg in.jpg
```

对于```gif```文件来说可以使用```gifsicle```工具，他是通过改变每帧比例，减小```gif```文件大小，同时可以使用透明来达到更小的文件体积。是一个公认的解决方案。可以去```http://www.lcdf.org/gifsicle/```中去安装。使用方式同样也是命令行方式。

```s
gifsicle --optimize=3 --crop-transparency -o out.gif in.gif
```

这里的优化级别不要小于```2```，```1```的话代表不压缩。压缩后基本不失帧。

还有一种压缩方式是图片可以根据网络环境来展示不同尺寸和像素的图片，通过在```url```后缀加不同参数来实现。比如下面的地址,```430```可以修改为```800```来获得不同体积的图片。

```https://img.alicdn.com/imgextra/i1/2616970884/O1CN01x6HnoK1IOuj5IosXO_!!2616970884.jpg_430x430q90.jpg```

### 2. 响应式图片

响应式图片是我们可以在用户不同的窗口大小还有设备像素的情况下来展示不同大小的图片，可以用以下三种方式来实现, 第一种是可以使用```js```来绑定事件检测窗口大小，以此来设置图片的大小。第二种方式就是```css```的媒体查询。

```css
@media screen and (max-width:640) {
    my_image { width:640px; }
}
```

第三种可以使用```html5```的```srcset```来设置，他会根据设备的像素比来自动选择需要的图片。而且不支持```srcset```的浏览器也可以正常展示```src```的属性。

```html
<img srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x" src="img-960w.jpg" alt="img" />
```

### 3. 逐步加载图片的方式

其实就是延迟加载，在真实的图片加载出来之前，可以使用一张公共的图片，一般是公司的```logo```，先将布局撑起来，然后再换成真实的图片。

```lqip```这个工具可以将真实的图片虚化，转换为很小的```base64```编码。这样我们可以先使用```base64```加载虚化的图片。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install lqip
```

```js
const lqip = require('lqip');
const file = './in.png';
// image
lqip,base64(file).then(res => {
    console.log(res); // 输出base64
})
// color
lqip.paletter(file).then(res => {
    console.log(res); // 图片颜色值
})
```

也可以使用低质量图片占位符, 他是基于SVG的图像占位符实现的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install sqip
```

```js
const sqip = require('sqip');

const result = sqip({
    filename:'./in.png',
    numberOfPrimitives:10 // 效果值
});

console.log(result.final_svg); // 输出svg格式
```

相比```lqip```来说```sqip```效果会好很多，而且可以设置不同的大小。

### 4. 其他方式

可以使用```web font```来代替图片，比如说小图标等业务小图片。

也可以用```dataurl```的方式，也就是前面的```base64```的方式来代替图片，这样用户就不需要发送```http```请求了。

也可以采用雪碧图将多个小图片合成一个大图，这样也会节省很多的图片请求。

### 5. 图片服务器自动优化

图片服务器优化是指可以在图片```url```连接上增加不同特殊参数，让服务器自动生成不同格式，大小，质量的图片。

比如说可以对图片做一些裁剪，裁剪成我们需要的图片，也可以支持不同格式的转换，比如说```jpg```，```gif```，```png```，```webp```等也可以设置图片的压缩比。

也可以对图片添加一些水印，高斯模糊，重心处理等还可以增加一些AI的能力，比如说用户上传的图片是否涉黄。还可以通过智能抠图，智能排版，智能配色智能合成等功能完善图片。

## HTML的优化方法

### 1. 精简html代码

可以减少```html```的嵌套也就是层级关系尽量减小，也可以减小```DOM```节点数也就是尽量压缩优化```DOM```的节点数, 让浏览器渲染的```DOM```节点数最少。

减少一些无语义的代码，比如说空标签清浮动那种代码```<div class="clear"></div>```能不用最好不要用。

建议连接中删除```http```或者```https```，因为一般链接的协议头和页面的协议头都是一致的，写他们多了```4-5```个字符其实是没有什么意义的。而且可以减少代码体积。

也可以删除多余的空格，换行符，缩进和不必要的注释，一般会用压缩工具来处理这个过程。可以省略一些标签和属性。使用相对路径的```url```，最大范围的减少字节数。

### 2. 文件位置

```css```文件链接尽量放在页面头部，```css```加载不会阻塞```DOM Tree```解析，但是会阻塞```DOM Tree```渲染，也会阻塞后面```js```执行。也就是说```DOM Tree```在渲染前就要解析好```CSS```，从而减少浏览器重排文档的次数。而且```css```放在页面底部会导致页面白屏时间变长。

```js```文件一般放在页面底部，这是防止```js```的加载和解析阻塞页面元素的正常渲染。

### 3. 用户体验

设置```favicon.ico```, 如果不设置控制台会报错，而且用户访问的时候地址栏也是空的，不利于品牌记忆。

增加首屏必要的```css```和```js```，一般页面需要在等待所有的依赖加载完成才会展示，这样就会导致页面存在空白。永祥用户体验，可以增加背景图或者```loading```或者骨架屏，比空白页好很多。

## CSS优化细则

### 1. 提升css渲染性能

谨慎使用一些```expensive```的属性，比如```nth-child```伪类或者```position:fixed```定位，因为这些比较消耗浏览器的渲染性能。

尽量减少一些样式层级的级数，比如，```div ul li span i { color:red}```, 其实我们可以给i标签设置```class```，直接书写样式。

避免使用占用过多```cpu```和内存的属性，比如```text-indent```不要设置太大的值。

尽量避免使用耗电量大的属性，比较占用```GPU```, 比如```transfrom```是，```transitions, opacity```。

合适的使用```css```选择器, 尽量避免使用通配符，避免使用```css```表达式。```color:expression((new Date()).getHours() % 2 ? "#fff" :"#000")```。

避免类正则的属性选择器。```*=```，```|=```，```^=```，```$=```，使用外链的```css```，可以单独形成文件放在```cdn```，使用缓存形式加载。避免使用```@import```因为他的加载会阻塞进程，需要加载完毕才会向下执行。

精简```css```代码，使用缩写的语句，比如```margin-top```可以写在```margin```中，再者如果值为```0```能删除就删除，删除不必要的单位值，删除过多的分号，删除空格和注释。尽量减小样式表的体积。其实这些都可以使用压缩工具来处理，会方便很多。

### 2. 合理使用web fonts

可以将字体文件部署到```cdn```上，加快用户端的加载速度，也可以将字体以```base64```的形式保存在```css```中，并通过```localStorage```进行缓存。一些谷歌字体库应该使用国内托管服务不要直接使用源地址。

### 3. css动画优化

避免同时动画，也就是说用户访问的屏幕区间里面不要有过多的动画，动画太多会干扰用户正常浏览网站，而且动画多也影响浏览器的性能。

延迟动画的初始化，可以让其它```css```先渲染，让动画延迟，比如说```0.5```或```1```。

可以借助```svg```去展示动画，样式放在```css```里面控制。

## JavaScript优化

首先我们是当需要的时候才去优化，不是为了优化而优化，一般的优化是在某一个时间点进行的，而且优化也需要考虑可维护性这是要结合团队的研发水平和代码的规范。

### 1. 提升js文件的加载性能

这个基本每个人都知道，就是```css```文件放在head标签中，```js```文件放在```body```结尾的地方。这个是```js```的加载不要影响```html```的渲染。

### 2. 变量和函数方面的优化

尽量使用```id```选择器，因为```id```选择器在查询效果上效率最快。

避免使用```eval```，这个方法比较消耗能行。

```js```函数尽可能保持简洁，不要把太多内容写在一个函数中。也建议使用事件的节流函数。事件委托等等。

### 3. js动画

尽量避免添加大量的```js```动画，```css3```动画和```canvas```动画都比```js```动画性能好。

使用```requestAnimationFrame```来代替```setTimeout```和```setInterval```，因为```requestAnimationFrame```可以在正确的时间进行渲染，```setTimout```和```setInterval```无法保证渲染时机。不要在定时器里面绑定事件。

### 4. 使用逻辑缓存

缓存```dom```对象，也就是用一个变量来存储```do```m对象，不要每次使用都查询。

缓存列表长度，也就是说用变量存储```dom```元素的个数，而不是每次都重新计算。

比如百度```M```站，会把页面的```css```和```js```放在本地存储里面，这样后面再加载的时候就直接从本地存储里面取，实现秒考的效果。不过本地存储空间有限，要谨慎使用。

### 5. WebWorker

可以将一些纯计算的工作迁移到```Web Worker```上处理，他为```JavaScript```的执行提供了多线程环境，主线程通过创建出```Worker```子线程，可以分担一部分自己的任务执行压力，在```Worker```子线程上执行的任务不会干扰主线程，待其上的任务执行完成后，会把结果返回给主线程，这样的好处是让主线程可以更专注的处理```UI```交互，保证页面的使用体验流程。

```js
// 创建Worker线程
const worker = new Worker('work.js')
// 主线程中关闭
worker.terminate();

// 子线程中关闭
self.close();
```

### 6. 节流和防抖

```js
function throttle(fn，delay) {
    let lastTime;
    let timer;
    delay || (delay = 300);
    rteurn function (arguments) {
        let context = this;
        let args = arguments;
        let nowTime = +new Date();
        if (lastTime && nowTime < lastTime + delay) {
            clearTimeout(timer);
            timer = setTimeout(function() { // 到达执行时间
                lastTime = nowTime;
                fn.apply(context，args);
            }，delay)
        } else { // 当前距离上次执行的时间大于等于设置时间，立即执行
            lastTime = nowTime;
            fn.apply(context，args)
        }
    }
}
```

```js
function debounce(fun，delay) {
    return function (arguments) {
        let context = this;
        let args = arguments;
        clearTimeout(fun.id)
        fun.id = setTimeout(function() {
            fun.call(context，args)
        }，delay)
    }
}
```

### 7. 慎用全局变量

```js
(function() {
    let str = '';
    for (let i = 0; i < 1000; i++) {
        str += i;
    }
})()
```

这个时候就相当是用两份不同的代码去完成了一个相同的效果。接下来把他们放在```JavaScriptperf```当中大量执行，从而得出谁的执行效率更高。

在```JavaScriptperf```中分别贴入这两段代码，运行脚本得出最终的性能结果。执行完成以后可以发现，采用全局变量和采用局部变量之间的差距是非常大的。

### 8. 通过原型对象添加附加方法

把某些调用频繁的方法添加在原型对象上，而不需要放在构造函数内部。比较一下两种不同的实现方式的性能。

```js
var fn2 = function() {}
fn2.prototype.foo = function() {
    console.log(11111);
}

let f2 = new fn2();
```

### 9. 选择最优的循环方法

```foreach```效率最高，```for...in...```效率最低。

### 10. 文档碎片优化节点添加

```DOM```操作是非常消耗性能的，特别是创建新的节点，将它添加至界面中时，这个过程一般都会伴随着回流和重绘。这两个操作对性能的消耗又是比较大的。

```js
// 使用优化
const fragEle = document.createDocumentFragment();
for (var i = 0; i < 10; i++) {
    var oP = document.createElement('p');
    oP.innerHTML = i;
    fragEle.appendChild(oP);
}
document.body.appendChild(fragEle);
```

### 11. 克隆优化节点操作

页面渲染完成之后页面中存在很多```p```标签，当要新增节点的时候，可以找到一个与新增节点类似的已经存在于页面中的节点，通过克隆的方式添加到界面当中。这样优化的内容是本身已经具有的样式和属性就不需要后续执行添加了，这就是所谓的优化。

```html
<body>
    <p id="box1">old</p>
    <script>
        // 克隆方式
        var oldP = document.getElementById('box1');
        for (var i = 0; i < 10; i++) {
            var newP = oldp.cloneNode(false);
            newP.innerHTML = i;
            document.body.appendChild(newP);
        }
    </script>
</body>
```

### 12. 直接量替换newObject

定义对象和数组的时候，有两种不同的形式，可以使用```new```的方式获取相应的数据，也可以直接采用字面量。

```js
// 字面量方式
var a = [1, 2, 3];

// 实例化方式
var a1 = new Array(3)
a1[0] = 1;
a1[1] = 2;
a1[2] = 3;
```

## 减少页面回流和重绘

### 1. css

避免过多的样式嵌套，最好可以快速的定位到元素。

避免使用```css```表达式，```css```表达式会在```css```绘制的过程中都会执行，会增加重排和回流的次数。

可以使用绝对定位让动画元素脱离文档流。

避免使用```table```布局他会引起浏览器的多次重绘，也不要使用```float```布局。

图片最好设置好设置```width```和```height```，这样图片在加载之后布局就可以确定了。

简化浏览器不必要额任务，使用```viewport```设置屏幕缩放级别。

避免频繁设置样式，将多个样式操作合并修改,一次性的更新。

### 2. js

为了减少回流发生次数，应该避免频繁操作``DOM``，可以合并多次对```DOM```的修改，一次性批量处理。

控制绘制过程和绘制区域，绘制过程开销比较大的属性设置应当避免使用。

## 简化DOM操作

众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量```DOM```元素，想想一下，从一个上万节点的```DOM```树上，使用```querySelectorAll```或```getElementByTagName```方法查找某一个节点，是非常耗时的，另外元素绑定事件时，事件冒泡和事件捕获的执行也会相对耗时。所以一般我们应该合理的不熟业务逻辑，```DOM```节点过多时应该延迟即将呈现的```DOM```内容。

对```DOM```的操作最好统一处理后再统一插入到```DOM Tree```中。可以使用```fragment```对```DOM```和样式设置好再统一放到页面中去。

目前比较流行的框架，比如```Angular```，```React```和```Vue```都是使用```虚拟DOM```技术，通过```diff```算法简化和减少```DOM```操作。

## 静态文件压缩工具

html-minifier:压缩```html```
clean-css:```css```的压缩工具
uglify-js:```js```文件的压缩工具

## 浏览器渲染过程

首先浏览器会解析```HTML```生成```DOM Tree```，然后解析```CSS```生成```CSSOM Tree```。接着```JS```会通过```DOM Api```和```CSSOM Api```来操作```DOM Tree```和```CSS Rule Tree```将```DOM Tree```和```CSSOM Tree```合成一颗渲染树```Render Tree```。

根据生成的渲染树进行回流，以计算每个节点的几何信息，包括位置，大小，样式等等。然后根据渲染树和回流得到的几何信息，得到每个节点上的绝对像素。

最后将像素发送给图片处理器也就是```GPU```进行页面展示。

前端页面渲染可以分为服务端渲染和客户端渲染。服务端渲染有传统的后端同步渲染，同构直出比如```php```，```java```,```.net```或者大家熟悉的```node```。

客户端渲染也就是```js```渲染，前后端分离，单页面应用。```react```,```vue```,```ios```,```安卓```，```hybird app```，```flutter```等。

## 懒加载，预加载，预渲染

懒加载也叫延迟加载，指的是长网页中延迟加载特定元素，可以是图片也可以是```js```和```css```。懒加载的好处是可以减少当前屏无效资源的加载。

一般我们会把```img```标签的```src```属性设置为空字符串，真实的图片地址放在```data-lazy```中，当页面```scroll```到对应的位置时再通过```DOM```操作将```src```的值替换为```data-lazy```的值。

预加载是让浏览器预先加载某些资源，同样也是图片，```js```或者```css```，这些资源是在将来才会被使用的。

简单来说就是讲所需要的资源提前加载到浏览器本地，后面在需要的时候可以直接从浏览器的缓存中获取，而不用再重新开始加载。好处是减少用户后续加载资源等待的时间。

可以使用```new Image```的方式也可以使用标签的方式```preload```，```prefetch```，```preconnect```

```html
<link rel="preload" href="src/style.css" />
<link rel="prefetc" href="src/image.png" />
<link rel="dns-prefetch" href="https://zhiqianduan.com" /> <!-- 提前将dns缓存-->
<link rel="preconnect" href="https://zhiqianduan.com" /> <!-- 提前加载需要的资源 -->
```

另一种预加载组件的方式就是提前渲染它，在页面中渲染组件，但是并不在页面中展示，也就是渲染好后先隐藏起来，用的时候再直接展示。可以使用```prerender```将```https://zhiqianduan.com```页面先提前渲染好。

```html
<link rel="prerender" href="https://zhiqianduan.com" />
```

## 接口服务调用优化

1. 接口合并，指一个页面的众多的业务接口和依赖的第三方接口统一使用一个部署在集群的接口统一调用，以减少页面接口请求数。

2. 接口上CDN，主要基于接口性能考虑，我们可以把不需要实时更新的接口同步至CDN，接口内容变更自动同步CDN。

3. 接口域名上CDN可以增强可用性和稳定性。

4. 接口降级，这个基于大促备战考虑，核心进行降级用基础接口进行业务实现，比如千人千面的推荐接口，在大促时间点可以直接运营编辑的数据，另外接口万一无法访问，使用预设好的垫底备份数据。

5. 接口监控，监控接口的成功率不是常说的服务器TP99，而是和用户实际情况一直的成功和失败监控，比如弱网，超时，网络异常，网络切换等情况。排查出来问题需要联合后端，运维，网络岗位人员一并解决。

从输入```url```到页面加载完成里面涉及到的每一步都有性能优化的空间。

1.用户输入```taobao.com```

2.浏览器通过```DNS```，把```url```解析为```ip```

3.浏览器和```ip```地址建立```tcp```链接，发送```http```请求

4.服务器接收请求后进行查库，读文件等，拼接好返回的```http```相应数据。

5.浏览器收到首屏```html```，开始渲染。

6.解析```html```中的```dom```

7.解析```css```

8.```dom + css```生成```render-tree```绘图

9.加载```script```的```js```文件

10.执行```js```脚本。

### 1. DNS缓存

全称是```domain name service```就是专门把域名转换为```ip```的这样一个服务，其实```DNS```也像是网络的一个协议。典型的一次```DNS```解析需要耗费```20-120```毫秒，所花费的时间几乎可以忽略不计，但是当网站中使用的资源依赖多个不同域的时候，时间就会成倍增加，从而增加了网站的加载时间。

一般来说前端优化与```DNS```有关的有两点，一是减少```DNS```的请求次数(缓存```DNS```地址)，二是进行```DNS```的预获取，```DNS Prefetch```。

```dns```缓存可以在服务器设置```DNS```缓存的时间，不经常变更的```ip```建议设置的时间长一些。尽可能使用```A```或者```AAAA```代替```CNAME```，使用```CND```加速域名。还可以自己搭建```DNS```服务。DNS预解析就是在html中声明一些link标签，在项目中如果涉及到其他域名的资源可以在加载过程中同时去处理```DNS```，这样在我们发起请求的时候```DNS```已经在本地缓存中了。

```html
<link rel="dns-prefetch" href="//q.alicdn.com" />
<link rel="dns-prefetch" href="//img.alicdn.com" />
```

### 2. TCP

```OSI```是七层架构，包括应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。```TCP/IP```简化到了四层，应用层，传输层，网络层，数据链路层。同样每一层慢了对性能都有影响。```TCP```是很重要的一个协议，```http```就是在```TCP```的基础上构建的，```TCP```理解也很简单，他就像是浏览器和服务器的聊天过程，这个过程也是性能优化的主要途径。在代码层面性能优化成效微乎其微，但是在网络层面的优化收益却是巨大的。

1.建立长链接

避免多次进行TCP链接，可以通过connection: keep-alive。

2.减少文件体积

浏览器再请求服务器的时候会在请求头中通过```Accept-Encoding```字段标识可以接收```gzip```压缩方案，服务器在收到请求后可以获取到这种压缩方案，将资源压缩后返回给浏览器，并且在响应头中加入```Content-Encoding```字段，值为```gzip```。

如果客户端不添加```Accept-Encoding```头，服务器返回了```Content-Encoding```，客户端如果支持的话也会正常解析。```Accept-Encoding```基本是浏览器自动添加的。

```js
const zlib = require('zlib');
const fs = require('fs');
const rs = fs.cerateReadStream('jquery.js');
const ws = fs.cerateWriteStream('jquery.js.gz');
const gz = zlib.createGzip();
rs.pipe(gz).pipe(ws);
ws.on('error', (err) => {
    console.log('失败');
})
ws.on('finish', () => {
    console.log('完成')
})
```

正常工作中```gzip```一般可以在```nginx```服务器中开启，不需要自己编写。还是比较简单的。```gzip```一般是针对文本文件，比如```js```，```css```，对于图片来说一般是在开发阶段压缩。

3.压缩请求头

```HTTP2```以前请求头是不可以压缩的，```HTTP2```引入了头信息压缩机制，一方面头信息使用```gzip```或```express```压缩后再发送，另一方面，客户端和服务器同时维护一张头信息表，通过索引字段来传输，减少厅信息数据体积。

实际工作中会存在请求正文非常大的场景，比如发表长篇博客，上报用于调试网络数据等等，这些数据如果能在本地压缩后再提交就可以节省网络流量，减少传输时间。

```DFLATE```是一种使用```Lempel-Ziv```压缩算法的哈夫曼编码压缩格式。

```ZLIB```是一种使用```DEFLATE```的压缩格式。

```GZIP```是一种使用```DEFLATE```的压缩格式。

```Content-Encoding```中的```deflate```实际上是```ZLIB```。

前端发送的时候可以进行压缩：

```js
const rawBody = 'content=test';
const rawLen = rawBody.length;

const bufBody = new Unit8Array(rawLen);
for (let i = 0; i < rawLen; i++) {
    bufBody[i] = rawBody.charCodeAt(i);
}

const format = 'gzip';

let buf;

switch (format) {
    case gzip': buf = window.pako.gzip(bufBody); break;
}

const xhr = new XMLHttpRequest();
xhr.open('POST', '/service/');

xhr.setRequestHeader('Content-Encoding', format);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')

xhr.send(buf);
```

服务器端进行解压

```js
const http = require('http');
const zlib = require('zlib');

http.createServer((req, res) => {
    let zlibStream;
    const encoding = req.headers['content-encoding']

    switch (encoding) {
        case 'gzip' : zlibStream = zlib.createGunzip(); break;
    }

    res.writeHead(200, { 'Content-Type': 'text/plain' });
    req.pipe(zlibStream).pipe(res);
}).listen(3000)
```

这种压缩一般也只适用于文本，如果数据量太大压缩过程也是比较耗时的。

4.减少文件请求次数

雪碧图，```js```和```css```打包，缓存控制，懒加载

5.减少用户和服务器的距离, ```cdn```使用

6.本地存储。

```http```会携带无用的数据，比如```header```和```cookie```，应该合理利用缓存机制解决这些问题。

### 3. 浏览器缓存机制

通过网络获取内容既速度缓慢又开销巨大，较大的响应需要在客户端与服务器之间进行多次往返通信，这回延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

在使用缓存技术优化性能的过程中，有一个问题是不可逾越的，既希望缓存能在客户端尽可能长久的保存，又希望他能在资源发生修改时进行及时更新。这是两个互斥的需求。如何兼顾二者呢？

可以将网站所需要的资源按照不同的类型去拆解，为不同类型的资源制定相应的缓存策略。首先HTML文件是包含其他文件的主文件，为保证当其发生改变能及时更新，应该将其设置为协商缓存.

```s
cache-control: no-cache
```

图片文件的修改基本都是替换，同时考虑图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可以采用强制缓存且过期时间不宜过长。

```s
cache-control: max-age=86400
```

```css```样式表属于文本文件，可能存在的内容不定期修改，还想使用强制缓存来提高重用效率，故可以考虑在样式表文件的命名中增加指纹或版本号(一般为```hash```值)，这样发生修改后不同的文件便会有不同的文件指纹，也就是请求的```url```不同。所以```css```的缓存时间可以设置长一些，一年。

```s
cache-control: max-age=31536000
```

```js```脚本文件可以类似样式表的设置，采用指纹和较长的过期时间，如果```js```中包含了用户的私人信息而不想让中间代理缓存，可添加```private```属性。

```s
cache-control: private, max-age=31536000
```

缓存策略就是为不同的资源进行组合使用强制缓存，协商缓存及文件指纹或版本号，这样可以做到一举多得，及时修改更新，较长缓存过期时间及控制所能进行缓存的位置。

缓存设置需要注意不存在适用于所有场景下的最佳缓存策略，凡是恰当的缓存策略都需要根据具体的场景考虑制定。缓存决策要考虑下面几种情况。

#### 1. 拆分源码，分包加载

对于大型项目来说，代码里是非常庞大的，如果发生修改的部分集中在几个重要的模块中，那么进行全量的代码更新显然比较冗杂，因此可以考虑在代码构建过程中按照模块拆分将其打包成多个单独的文件。这样在每次修改后更新提取时，仅需拉取发生改变的模块代码包，从而大大降低了需要下载的内容大小。

#### 2. 预估资源的缓存时效

根据不同资源的不同需求特点来规划响应的缓存更新失效，为强制缓存指定合适的```max-age```，为协商缓存提供验证更新的```ETag```实体标签。

#### 3. 控制中间代理的缓存

凡是涉及用户隐私信息的尽量避免中间代理的缓存，如果对所有用户响应相同的资源，则可以考虑让中间代理也进行缓存。

#### 4. 避免网址的冗余

缓存是根据请求资源的```URL```进行的，不同的资源会有不同的```URL```，所以尽量不要将相同的资源设置为不同的```URL```。这会导致缓存失效。

#### 5. 规划缓存的层次结构

不仅请求的资源类型，文件资源的层次结构也会对制定缓存策略有一定的影响。如果并发请求了相同的资源使用了不同的域名，那么之前的缓存就失去了意义。

删除冗余代码的```tree-shaking```，和去除无效代码，我们在webpack那里都介绍过了，这里不赘述了，如果是个别页面使用了```echarts```这种库，一定记得懒加载。

## 接口缓存优化

1. ajax/fetch缓存，前端请求的时候带上cache，依赖浏览器本身的机制来请求接口，这个比较适用于不会经常变更的数据。

2. 本地缓存，异步接口数据优先使用本地localStorage中缓存的数据。可以让服务端返回数据的时候再给一个md5值，然后将md5值和数据绑定存在本地，再次请求的时候对比这个md5值，如果相同就不要再请求获取数据的接口了，如果不同就请求更新。

## webview

原生的```webview```对于```IOS```来说有两种，一种是```UIWebView```，他从```IOS2```开始就作为```App```内展示```web```内容的容易，而且排版布局能力比较强。

不过```UIWebView```也有很多的问题，比如说内存泄漏，运行期间会有极高的内存峰值，```Touch Delay```延迟300毫秒。```js```运行性能不高，在```2018```年的```ios12```以后就不再维护了。

```WKWebView```是苹果在```WWDC 2014```上推出的新一代```WebView```组件，```WKWebView```的内存开销比```UIWebView```要小很多，而且在性能，稳定性，内存占用方面都有很大提升。可以实现```60fps```的滚动刷新率，自身就支持了右滑返回手势，支持更多的```HTML```属性。内存占用是```UIWebView```的```1/4 ~ 1/3```, 加载速度比```UIWebView```提升了一倍左右。大幅度提升了```js```执行速度。允许```js```的```Nitro```库的使用，```UIWebView```是不允许的。可以和```js```直接互调函数，不需要使用```jsbridge```来协助。

当然```WKWebView```不支持页面缓存，需要自己注入```cookie```，而```UIWebView```是自动注入```cookie```的。他也无法发送```POST```参数。

对于安卓来说存在```webkit for webview```和```chromium for webview```。

```webkit```是一个开源项目，前身是```khtml```和```kjs```，专注于网页内容的展示，做了一流的页面渲染引擎，他不是浏览器而且也不想成为浏览器，这个项目包含两个部分，第一个部分是```WebCore```, 其中包括对```html```，```css```很多```w3c```规范的实现，第二部分就是狭义上的```webkit```主要是各个平台的移植并提供相应的接口。也就是```webview```和类似于```webview```，这样的接口提供操作和显示网页的能力。

目前使用```WK```的主流浏览器或者```webview```包括```chrome```，```safari```, 安卓平台以及众多的移动浏览器。

```chromium```是基于```webkit```之上的一个浏览器项目，由谷歌来发起，这个项目发展的还是比较迅速的，他对新特性的支持还是比较好的，比如```webgl```，```css3```，```h5```等等，在性能方向也非常不错```chrome```一般选择稳定的```chromium```作为基础。

| | Webkit for Webview | Chromium from Webview | 备注 |
| ---- | ---- | ---- | ---- |
| 版本 | Android4.4以下 | Android4.4以上 | -- |
| JS解释器 | WebCore JavaScript | V8| -- |
| H5 | 278 | 434 | -- |
| 远程调试 | 不支持 | 支持 | Android4.4及以上支持 |
| 内存占用 | 小 | 大 | 相差20-30M|
| WebAudio | 不支持 | 支持 | Android 5.0及以上支持 |
| WebGL | 不支持 | 支持 | Android 5.0及以上支持 |
| WebRTC | 不支持 | 支持 | Android 5.0及以上支持 |

安卓第三方内核，主要是安卓的版本较多，对```WebView```二次封装产生的，这里主要说下```X5```内核。

他的速度是比较快的相比系统```WebView```的网页打开速度有```30%```的提升，在流量方面使用云端优化技术节省```20%```以上。安全问题可在```24```小时内修复。更稳定经过亿级用户的使用考研，```CRASHE```(崩溃)率低于```0.15%```。没有系统内核的碎片化问题，更小的兼容性问题，支持夜间模式，适屏排版，字体设置等浏览器增强功能。在```H5```和```ES6```上有更完整的支持，集成了强大的视频播放器，支持视频格式远多于系统的```WebView```，视频和文件的格式支持X5内核多于系统内核，自带防劫持。

一般```webview```选型，```IOS```建议使用```WKWebView```, 安卓建议使用```X5```。

## WebView性能优化

当```App```首次打开时，默认是不初始化浏览器内核的，当创建```WebView```实例的时候，才会启动浏览器内核，打开事件需要```70-700```毫秒，并创建```webview```的基础框架。

可以使用全局的```Webview```对延迟的毫秒进行优化，就是在客户端启动的时候，就初始化一个全局的```WebView```待用，当用户访问```Webview```的时候直接使用这个```WebView```加载对应网页。

这样会减少首次打开```WebView```的时间，缺点是会有一些额外的内存消耗。

导航栏可以预加载，以前是在```webview```加载完成之后进行初始化，可以改为和```webview```并行一起加载。

对于登录来说```H5```页面上接口每次查询```Cookie```中是否有登录态，无登录态```H5```跳转统一登录页，```App```登录成功写入```Cookie```。可以改为```Cookie```统一在```Webview```中设置```cookie```。也就是初始化```Webview```的时候判断是否登录，如果登录了就打开```H5```页面，如果没登录就自动跳转登录页面。

```webview```加载页面的```url```尽量前置，不要放在最后，可以和业务逻辑并行处理，总而言之减少页面的白屏时间，让用户最快的看到页面。

提升滚动条的使用体验，原本是使用系统自带的滚动条的进度值，可以自己模拟滚动条的加载过程，让用户感觉页面加载变快了。也就是初始快速的加载到```60%```以上，给用户感觉加载很快的感觉。其实真实速度并没有变...

```js-sdk```优化，也就是```oc```和```js```通信的一个方式。一般```jssdk```有三种方式实现，第一种就是常见的```scheme```的方式，就是我们在```h5```页面里面定义一些特殊的链接，拿到这个```scheme```之后原生拦截。然后把需要的回调函数和参数进行拦截，但这样有个问题，```url```一般是```256```个字符，有长度的限制不能无限的传递。

第二种是```iframe```的形式，通过后台启一个页面进行拦截取```iframe```的变更拿到```js```的方法给```oc```实现通信，```iframe```是依赖```jssdk.js```文件的，需要```sdk```文件作为桥梁实现通信目的。

第三种是```webkit```的方式，他是一种直接调用的方式，无需依赖任何的```sdk```文件。

浏览器缓存策略

| 缓存机制 | 优势 | 适用场景 | Android 开关 | IOS开关 |
| ---- | ---- | ---- | ---- | ---- |
| 浏览器缓存机制 | HTTP协议层支持 | 静态文件的缓存 | 浏览器负责 | 浏览器负责 |
| Web Storage | 较大的存储空间，使用简单 | 临时，简单数据的缓存，浏览器上的LocalStorage、SessionStorage| webSettings.setDomStorageEnabled(true)| 默认开启无关闭 |
| Web SQL Database | 存储，管理复杂结构数据 | 建议用IndexDB 替代 | webSettings.setDatabaseEnabled(true) | 默认开启无关闭 |
| Application Cache | 方便构建离线App | 离线App,静态文件缓存 | webSettings.setAppCacheEnabled(true) | 默认开启无关闭 |
| IndexDB | 存储任何类型数据，使用简单，支持索引 | 结构，关系复杂的数据存储 | webSettings.setJavaScriptEnabled(true) | 默认开启无关闭 |

## H5离线化的实现方式

全局离线包，包含公共的资源，可供多个应用共同使用。

还可以有私有化的离线包，只可以被某个应用单独使用。

离线包的工作原理:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6618760a0bf0432eab665b0d437c307b~tplv-k3u1fbpfcp-watermark.image)

首先会加载一个全局的包就是一些基础的文件，加载之后会把包释放放在内存里，接着会做一个检测，查看本地是否安装，如果已经安装就释放到内存，如果没有安装就触发离线包的下载，就是我们做好的包放在服务器中，然后从服务器获取过来，在下载之前会进行一个本地和线上版本的对比，版本不一致的话就会下载最新的包，如果一致就取本地的就可以了。

最终这个包会解压释放在内存里面，当```webview```在加载```url```的时候会直接从内存里面读取，如果能读取到就加载内存中的页面数据进行展示，假设读取不到也就是说本地没有这个业务就会使用线上的```url```地址让页面加载就可以了。因为我们一般不会把所有的业务都做成离线化的形式，假设```webview```查询的到就用离线化，查询不到就用垫底的线上```url```展示。无论本地离线包加载失败还是没有这个离线包，都使用线上```url```来垫底。

离线包的下载一包情况下如果用户处于移动网络状态下，不会在后台下载离线包，如果当前用户点击app，离线包没有下载好，用户就要等待离线包下载好才能用。可以采取```wifi```静默下载的方案。

从服务器请求的离线包信息存储到本地数据库的过程中，离线包信息包括离线包的下载地址，离线包版本号，加密签名信息等，安装离线包其实就是将离线包从下载目录拷贝到手机安装目录。

一些大厂的离线包方案比如美团的```LsLoader```通用移动端```WebApp```离线化方案，腾讯的```Alloykit```离线包，阿里的极致```Hybrid```航旅离线包再加速。原理基本上都是一致的，细节上可以做些参考。

## 混合开发

```React Native```是基于```React```语法的, 希望实现的是一套代码可以在各个端使用。他的优势很明显，代码是可以共享的无论是```IOS```还是安卓还是```H5```,性能方面几乎也与```Native```相同。并且提供了非常流畅的动画，因为他在渲染之前代码就已经转换为了原生视图。

调试时无需每次代码变更都编译打包，可即时查看更小效果，极大提高了开发人力。

支持热更新，不需要每次发版都发布应用到商店，发版时间可以自由控制，安卓和```ios```同时发版。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cec7ff173d3e4224994ffabd3c22d51a~tplv-k3u1fbpfcp-watermark.image)

一共分成四层实现，最下面是```native```的原生层也就是```OC```和```Java```，在这之上是UI渲染器，图片处理，网络通信，和一些工具库，再向上是```C++```:```JSCore```，```Bridge```也就是```js```的运行环境和```js```和```native```的桥接。最上面才是```js```层也就是```js```的一些组件。

```RN```的```jsx```文件通过```JSBridge```会针对不同平台打包成不同的格式，比如```IOS```的```.m```文件，安卓的```.xml```文件，以及```H5```的```.html```文件。

为什么会有```RN```其实是因为应用商店发版的问题，每一次发版都需要审核，可能审核不通过，而且安卓可能要发布多个商店，还有两端研发不同步的问题，也就是安卓和``ios``相同的业务需要开发两遍。

如果你公司的技术是```React```全家桶，那还是建议选用```RN```的。

小程序的愿景是触手可及，用户扫一扫或者搜索下就可以打开应用，不需要安装太多应用。

程序相比```App```，开发门槛更低，优于```H5```接近```Native```的体验，可以使用相机，位置，网络，存储等丰富的原生能力。支持顶部下拉，搜索，扫码等入口，简单方便，用完即走，不需要像App那样下载，直接打开支持热更新。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4af6fe65fff64247aad5379ea9813394~tplv-k3u1fbpfcp-watermark.image)

小程序出现的行业背景，对于```App```大厂来说需要流量变现，比如微信，他是没办法变现的，所以可以使用小程序生态将第三方引入进来，形成了一个小型的应用市场。对于企业应用来说，移动流量枯竭，获客比较困难，可以降低获客成本和开发成本，业务上提供更多的试错机会。

平台类产品如果输出给商家端，相比多个```app```的方式，比较推荐使用小程序。

Flutter号称编写一次可以部署到各个终端，```web```,```android```，```ios```，```mac```，```linux```，```windows```，```fuchsia os```。

底层使用```Skia```图形引擎，图形性能媲美原生应用，界面更像一个全屏应用程序或```2D```游戏，速度比较快，使用本机```ARM```二进制文件，做到提前编译，不需要```JVM```，也就是```java```虚拟机。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ccb0aca9b634042924fe4cb0bd1b46d~tplv-k3u1fbpfcp-watermark.image)

底层实现

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/963f5a72778c4c97a4d6d9ae4de2c276~tplv-k3u1fbpfcp-watermark.image)

```flutter```在```2017```年```5```月份出现，生态不够丰富，学习曲线相对较高，但是他的性能较好，如果考虑性能，团队人员足够的话建议选择```fluttr```。

## CDN

```CND```全称是```Content Delivery Network```，内容分发网络，他是构建在现有网络基础上的虚拟智能网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡，调度及内容分发等功能模块，使用户在请求所需访问的内容时能够就近获取，以此来降低网络阻塞，提高资源对用户的响应速度。利用每一台最靠近用户的服务器，更快更可靠的将文件发送给用户。以加快访问速度。

```CDN```的有点很明显，因为会给用户指派较近，较顺畅的服务器节点，所以速度会比较快，服务器放在不同地点，减少了互联的流量，也降低了快带成本，当某个服务器故障时，自动调用临近地区的服务器。

回源是指浏览器访问```CDN```上静态文件时，文件缓存过期，直接穿透```CDN```而访问源站机器的行为。这是```CDN```的一个策略。

```CDN```的缓存分为三级，浏览器本地缓存也就是```header```头配置的缓存，```CDN```边缘节点缓存，```CDN```源站缓，一般是三级，也可能业务比较少就采用两级缓存，浏览器缓存和```CDN```源站缓存。

缓存时间设置过短的话，```CDN```边缘节点缓存经常失效，导致频繁回源，增大了源站负载，访问速度也会变慢，缓存时间设置的过长，文件更新慢，用户本地缓存不能及时更新，所以一般是结合业务情况而定。

一般不同资源类型缓存时间设置不用，```html```一般```3```分钟左右，```js```，```css```可以```10```分钟，```一天```，```一个月```，看变更情况。

现在一般我们文件的命名都会以```hash```串的形式，如果文件有变更生成的文件名就会有变更，否则还是之前的名字，这样我们缓存的时间就可以设置的长一些。

```CDN```可以灰度发布，也就是在部分地区部分运营商优先发布静态资源，验证通过后再进行全量发布。具体实施可以从域名方面下手，设置特殊```VIP```解析到要灰度的城市或者运行商。也可以调整源站机器，给灰度的城市或者运营商配置单独的源站机器。

一般在活动期间比如说大促，需要增加机房宽带，增加运营商流量，增大```CDN```缓存时间等等。

## DNS

```DNS```是将网站域名和地址互相映射的一个分布式数据库，我们访问一个网站首先会通过```DNS```将域名匹配为```ip```地址，然后再通过ip地址去访问对应的服务器。

客户端里面有一个```http dns```, 客户端直接访问```http```的接口，可以获取业务在域名访问系统中配置的最优```ip```，基于容灾的考虑，```app```内是需要保留使用运营商```DNS```解析方式的，客户端再获取到```ip```后会直接向ip中发送业务请求。

比如一个```http```请求，在```header```中会指定```host```字段，向```ip```发送标准的```http```请求就可以了，总的来说采用```http-dns```来解析域名能绕过三四级运营商接续域名出现的一些问题，在```http-dns```返回的正确```ip```之后是直接使用```ip```去发送```http```请求的，只需要关注通信内容的安全就可以了。

安卓系统可以采用```okhttp```模块，他支持```http2```,```http2```可以在一个链接上一次性发送多个请求，支持```gzip```，也支持响应缓存避免网络重复请求，如果服务器配置了多个``ip``地址，当第一个```ip```链接失败的时候，```okhttp```会自动尝试下一个```ip```地址。

```ios```没有现成的模块，我们可以在```app```启动时，缓存所有可能要用到的域名```ip```比如接口，网关，同时异步处理，客户端无需得到缓存结果。如果```cache```中有此域名的圆环，直接返回缓存的```ip```，如果缓存中没有此域名，则重新向```httpdns server```进行申请然后缓存下来。

```H5```的做法一般是设置多个域名，因为浏览器对并发数是有限制的，一个域名一般最大连接数是6，所以我们可以将用户访问的一些```api```接口作为一个域名，页面中的样式和资源可以设置成一个域名，图片也可以单独设置成一个域名，甚至多个域名，来打破浏览器的这种限制。

## http优化

```http```的优化主要就是减少请求数，这可能是我们日常工作中经常遇到的，也是大家耳熟能详的。

图片可以使用雪碧图，```dataurl```,```webfont```。

可以考虑将业务中的```js```或者```css```合并，不要切割的太小。如果不想合并成一个可以使用```Combo```的方式让服务去返回，可以在```url```上通过参数的形式告诉服务加载那些资源。

接口也可以合并，不要拆分的太细，可以让服务去合并，不经常变化的接口和资源也可以存储在```LocalSrorage```，有变化就更新，没有变化就从本地取。

有些时候我们的某个页面会出现问题，或者打开白屏，但是接口没有问题，页面也没有问题，资源也是可以访问通的，这个时候可能就是```cookie```太大了，已经超出了原本可控的范围，我们都知道```cookie```是会随着页面间的跳转携带的，这就肯能导致页面无法访问，这种问题不常见，但实际工作中确实会遇到。

可以在页面中设置```cookie```白名单，意思就是定期检查我们的```cookie```，如果是需要的就保留，不需要的就删除，定期整理。```cookie```控制可以减小页面间传输的大小，也可以对```cookie```进行有效的管理。

## 服务器缓存配置

当一个文件被浏览器加载的时候我们实际上是不知道这个文件是否是过期的，所以浏览器和服务器之间存在一种约定，通过```header```头的配置，确定文件是否过期。

一般在响应头中包含一个```expires```的头信息，他的值为日期+时间，表示在此时间之后，响应过期，如果数值为```0```，表示资源已经过期。

当然如果响应头中包含```Cache-Control```, 设置了```max-age```或者```s-max-age```指令，那么就会忽略```expires```，而取```Cache-Control```。

```Cache-Control```通过制定的指令来实现缓存机制，缓存指令是单向的，这意味着在请求中设置的指令不一定被包含在响应中。他的语法比较简单，```Cache-Control:max-age=秒```设置缓存存储的最大周期，超过这个时间缓存被认为过期。

```ETag```是资源版本的标识符，可以让缓存更搞笑，并节省带宽，因为如果内容没有改变，```Web```服务器不需要发送完整的响应，如果发生了改变，使用```ETag```有助于防止资源的同时更新相互覆盖。

```ETag```类似于指纹，也可能被某些服务器用于跟踪，比较```ETag```能快速确定资源是否变更，但也可能被跟踪服务器永久存留。

```s
ETag:"5c6cccc123-1d45"
```

```Last-Modified```是一个响应收不，其中资源包含源头服务器认定的资源做出修改的日期和时间。他常被用作一个验证器来判断接收到的或者存储的资源是否一致。由于精度比```ETag```要低，所以这是一个备用机制，包含有```if-Modified-Since```或```If-Unmodified-Since```首部的条件请求会使用这个字段。

```Date```是通用的首部，其中包含了报文创建的日期和时间。

```Gzip```，可以对文本进行压缩，一般是```html```，```css```，```js```，对于非文本不会压缩，比如说图片资源，压缩比率可以达到```50%-70%```

## 本地测试开启https

这个内容不应该写在这，但是实在不知道写在哪了。

```https```这里就不过多介绍了，毕竟不是这篇该有的内容。

浏览器目前基本上已经默认开启了```https```，所以为了```SEO```我们也建议使用```https```，而且```https```也更加安全。

如果是对外的网站我们需要和经销商购买```ssl```证书，可以在```gogetssl```，```ssls.com```,```sslmate.com```中去购买，当然这些证书是有时效的。

如果本地测试的话，也可以在本地安装一个测试证书，我们可以通过```mkcert```来实现。首先需要安装它。

```s
brew install mkcert
```

安装根证书

```s
mkcert ---install
```

生成本地签名，给```123.com```

```s
mkcert 123.com
```

这样就生成了一对证书，我们可以将这对证书配置在```nginx```里面，具体配置方法可参考我之前写的```nginx```文章。

## http2

```http2```是```http```的第二版，简称```h2```或```h2c```，它采用二进制传输数据，多路复用，允许通过一个链接发起多个请求，所以一般使用```h2```雪碧图就没什么用了，他超出了浏览器限制最大连接数的局限，对```header```头进行压缩从而降低传输体积，支持服务端推送(```server push```)，可以从服务端将数据推送给客户端。

开启```HTTP2```可以降低服务器压力，提升网站访问速度，而且可以更好的保护网站安全因为他是强制使用```https```的。

开启```http2```其实也很简单，我们需要重新编译```nginx```，并且开启```http_ssl_module```和```http_v2_module```

```s
cd nginx-xxx
./configure --with-http_ssl_module --with-http_v2_module
make && make install
```

同样这里可以参照之前我写的```nginx```文章，其实就是在```listen 443```端口后添加```http2```标识。

```s
server {
    listen 443 ssl http2;
}
```

## 前端的研发流程

首先是技术选型，包括页面渲染技术和混合式开发技术，然后是项目的初始化，包括```React```，```Vue```，```Angular```，依赖模块引入，一般会存在一个私有的```NPM```，接着开始本地开发，方便前端调试和看到效果，项目联调，产品和设计师对效果进行确认，最后项目整体部署上线。

项目开始之前前后端会指定一些数据接口，有了接口文档前后端就可以并行开发，前端开发页面和交互，后端开发业务逻辑。都开发完后前后端开始进行联调，最后发布上线。

## 自动化测试

```UI```自动化，上手比较简单，不过稳定性较差，常用的工具有```appium```，他是一个开源的工具用于自动化```ios```手机，安卓手机还有```windows```桌面的一个测试工具，```robot framework```是基于```python```可扩展的关键字测试框架用于端到端，验收测试以及测试驱动开发，可用于测试分布式异构应用程序包括可以验证涉及多种技术的接口，```selenium```用于```web```应用程序测试工具可以直接运行在浏览器上，可以和用户的真正操作是一样的，支持```ie```,```火狐```，```谷歌```，```欧朋```等常用浏览器，主要用来测试浏览器的兼容性。```airtest```支持自动化的脚本录制一键回收，轻而易举就能实现自动化测试流程，还是比较常用的。

接口自动化，使用稳定，性价比非常高，工具有```java + restassured```，是```java```实现的，轻量级的可以通过编写代码向客户端发送请求并且验证返回结果。```python + requests```主要对```python```接口进行测试, JMeter用于对软件做压力测试，```HttpRunner```只需要一份脚本就可以实现自动化测试性能测试，线上监控，持续集成等多种测试的需求。

单元测试，性价比极高，一般由开发完成，但是有一些单元测试框架，```Junit5```，```pytest```，```unittest```。
