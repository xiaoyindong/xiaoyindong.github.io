## 1. 第一阶段

以文件拆分的方式实现模块化，这也是```web```中最原始的模块系统，开发时拆分不同的```js```文件，在```html```中引入所有的```js```依次执行。

```html
<body>
    <script src="module_A.js"></script>
    <script src="module_B.js"></script>
    <script src="module_C.js"></script>
</body>
```

代码会污染全局作用域，所有的代码在全局工作，没有私有空间，模块中的内容可以在模块外被访问和修改。容易产生命名冲突问题。模块无法管理各自的依赖关系，完全依靠约定，项目到一定体量无法维护，出现各种奇怪的命名。

## 2. 第二阶段

约定每个模块只暴露一个全局对象，成员挂载在这个对象下面。通过命名空间的方式可以减小命名冲突的问题，但是仍旧没有私有空间，模块成员可以在外部被访问和修改，模块间的依赖关系也没有被解决。

```javascript
var module_A = { // 所有的成员都挂在module_A这个对象上。
    name: 'yd',
    age: 18,
}
```

```html
<script src="module_A.js"></script>
<script>
    module_A.name; // yd 可以被访问
    module_A.name = 'zd'; // 可以被修改
    module_A.name; // zd
</script>
```

## 3. 第三阶段

每一个模块中所有的内容放到一个函数的私有作用域中，将需要对外暴露的成员，通过挂载全局对象的方式实现。

```js
;(function($) {
    var name = 'module_A';
    function setBackColor() {
        $('body').css({ backgroundColor: 'yellow'});
    }
    window.module_A = {
        name: name,
        setBackColor, setBackColor
    }
})(jQuery)
```


实现了私有成员的概念。自执行函数的参数可以作为依赖声明去使用，每个模块之间的依赖关系实现十分明显。比如使用```jQuery```就接收```jQuery```参数，在后期维护的时候，就可以知道想要使用该模块就要引入```jQuery```。

这种方法是早起在没有工具和规范的情况下，对模块化思想的落地方式，解决了前端领域在模块化遇到的各种各样的问题。

## 4. CommonJS

```NodeJS```提出的一套模块化标准，在```NodeJS```中所有模块必须遵守的规范，规定:

1.一个文件就是一个模块

2.每个模块都有独立的作用域

3.通过module.exports 导出成员

4.通过require函数载入模块。

```CommonJS```以同步的模式加载模块的，因为```Node```执行机制是在启动时加载模块，执行过程中不需要加载模块只会使用模块。

这种方式在浏览器端必然导致效率低下，因为每次页面加载都会导致大量同步请求出现，所以早期并没有选择```CommonJS```而是专门为浏览器端重新设计了一个规范。

```js
// 定义模块math.js
var basicNum = 0;
function add(a, b) {
  return a + b;
}
module.exports = { //在这里写上需要向外暴露的函数、变量
  add: add,
  basicNum: basicNum
}

/** 必须加./路径，不加的话只会去node_modules文件找 **/
// 引用自定义的模块时，参数包含路径，可省略.js
var math = require('./math');
math.add(2, 5);

// 引用核心模块时，不需要带路径
var http = require('http');
http.createService(...).listen(3000);
```

```exports```对于本身来是一个变量并不是```module```的引用，它是```{}```的引用，指向```module.exports```的```{}```模块。只能使用```.```语法 向外暴露变量。

```js
exports.name = "yd";
```

```module```是一个变量，指向一块内存，```exports```是```module```中的属性，存储在内存中，```exports```属性指向```{}```模块。既可以使用```.```语法，也可以使用```=```直接赋值。

```js

module.exports.name = "yd";

module.exports = {
    name: 'yd'
}
```

## 5. AMD

```Asynchronous Module Definition```异步的模块定义规范，```requireJS```库实现了```AMD```规范。

每个模块要通过```define```方式定义，可以传递三个参数，第一个参数是当前模块的名字，供其他模块引入使用，第二个参数是一个数组，声明依赖哪些模块，第三个参数是回调函数，依赖加载完成之后，执行该函数，函数中的参数是对应的模块对象。返回值是被其他模块引用时的导出内容。

```js
define('module1', ['jQuery', './module2'], function($, module2) {
    return {
        start: function() {
            $('body').css({ backgroundColor: 'yellow'});
            module2();
        }
    }
})
```

模块加载使用```require```，用法和```define```类似，只是接收两个参数，第一个参数是依赖的模块数组，第二个参数为回调函数。

```js
require(['jQuery', 'module1'], function($, module1) {
    // 业务代码
    module1.start();
})
```

```require```加载模块的时候，内部会发送一个```script```请求，加载对应的模块脚本，并且执行相应模块的代码，目前绝大多数第三方库都支持```AMD```规范。```AMD```的生态还是比较好的，只是使用起来比较复杂。

因为在编写业务的时候，除了业务代码还要编写很多的```define```，```require```等操作模块的代码，会导致代码复杂度提高，项目中如果模块划分过于细致的话，会导致模块```JS```请求频繁，请求次数越多页面效率也就越低。

## 6. CMD

```Common Module Definition```，有点类似```CommonJS```，使用上和```requireJS```差不多，算是一个重复的轮子，当时的想法是希望```CMD```写出来的代码尽可能的与```CommonJS```类似，从而减轻开发者的学习成本，不过这种方式在后来也被```requireJS```兼容了。

```AMD```推崇依赖前置、提前执行，```CMD```推崇依赖就近、延迟执行。此规范是在```sea.js```推广过程中产生的。

```js
/** CMD写法 **/
define(function(require, exports, module) {
    var a = require('./a'); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require('./b');
        b.doSomething();
    }
});

/** sea.js **/
// 定义模块 math.js
define(function(require, exports, module) {
    var $ = require('jquery.js');
    var add = function(a,b){
        return a+b;
    }
    exports.add = add;
});

// 加载模块
seajs.use(['math.js'], function(math){
    var sum = math.add(1+2);
});
```

## 7. ES Module

```ECMAScript2015```当中定义的一套模块系统，是最近几年才被定义的一套标准，```ES Module```可以说是最主流的前端模块化方案。

绝大多数浏览器已经支持```ES Modiule```了，通过给```script```标签添加```type=module```的属性就可以使用```ES Module```的标准去执行```javascript```代码。

```html
<script type="module">
console.log('this is es module');
</script>
```

在```ES Module```规范下，代码会默认采用严格模式(```use strict```)运行，并且每个```ES Module```都运行在单独的作用域中，也就意味着变量间不会互相干扰。外部```js```文件是通过```CORS```的方式请求的，所以要求外部的```js```文件地址要支持跨域请求。```ES Module```的```script```标签会延迟脚本加载，等待网页请求完资源之后才执行，这和使用```deffer```的资源方式请求相同。

### 1. 基本使用

在一个模块中，可以使用```export```导出模块中的内容, 无论是变量，函数，还是```class```对象

```js
var foo = 'es module';

function hello() {
}

class Person {
}

export { foo, hello, Person, foo }
```

导出时可以使用```as```改变导出成员的名称。

```js

export { foo, hello, Person, foo as fooName }
```

使用```import```引入模块内容，

```js
import { foo, hello, Person, fooName } from './module.js';
```

一旦将导出成员的名称设置为```default```，那么在引用的时候就一定要把这个成员重命名掉，因为```default```是一个关键字，不能把他当做一个变量使用。

```js
// 导出
var foo = 'es module';

export {
    default: foo,
}
// 导入
import { default as fooName } from './module.js';
```

```default```作为默认导出使用，引入的时候可以使用一个合法的名字接收默认导出内容

```js
// 默认导出
export default 'yd';

// 导入
import name from './module.js';
```

使用```ES Module```导出成员的时候，比如下面这种情况。

```js
var name = 'yd';
var age = 18;
export { name, age };
```

```export {}``` 是一个固定的语法，和对象的没有任何关系，```export```单独使用的时候必须要用两个花括号包裹导出的成员。如果想要导出一个对象的，就不能使用```export```导出，而是要改成```export default {}```; 这才是字面量的含义，这和```ES6```的解构完全不同。

```js
var name = 'yd';

export { name }; // 固定语法，导出name

export default { name }; // 导出一个对象，对象中包含name属性。

export default name; // 导出 name 变量
```

一旦使用了```export default```导出，就不能使用下面的方式导入，即使导出的是一个对象。

```js
import { name } from './module.js'; // 不能使用该方式导入默认导出的对象
```

```export {}```和```import {}```是一个固定的约定用法，想要导出具体变量或者对象，要用```export default```和```import modulename from 'moduleName'```;

### 2. export

```export```导出的是成员的引用，并不是真正导出了成员的值，也就是导出之后，访问的仍旧是原本模块的内存空间。

```js
var name = 'yd';

setTimeout(function() {
    name = 'zd';
}, 1000);

export { name };
```

定义```name```属性```1s```后改变```name```的值，新模块中```1.5s```后打印该内容。

```js
import { name } from './module.js';

setTimeout(function() {
    console.log( name ); // zd
}, 1500)
```

打印的是```zd```，并不是```yd```。所以说模块暴露出来的只是一个引用关系并且它是只读的，并不能在模块外部修改这个变量也就是不能在```import```的模块中修改```name```的值。

### 3. import

```import```引入文件的时候，必须书写完整文件名称，不能省略扩展名。如果使用相对路径加载资源```./```也是不能省略的，省略会认为加载的是第三方资源，这一点与```CommonJS```规范相同。它也支持使用```/```开头的绝对路径，也就是从网站的跟目录开始的路径，也可以使用完整的```url```加载模块。

```js
import & from 'https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js';
```

如果只是需要加载某个模块，并不需要提取这个模块的成员的话，花括号中可以不写成员，也可以省略花括号

```js
import {} from './module1.js';
import from './module2.js';
```

如果一个模块导出的成员很多，导入的时候都需要使用这些成员，可以使用```*```号，也可以通过```as```生成一个新的对象，将所有成员挂载在上面。

```js
import * as mod from './module.js';
```

```import```关键词只能写在模块最顶层，不能写在```if```和函数中，导入的时候必须要写明路径，不能使用变量替代。

```js
if (true) {
    import { name } from './module.js';
}

var module = './module.js';

import { name } from module;
```

可以使用```ECMAScript2020```中新增的异步导入功能返回的是一个```Promise```对象。

```js
var module './module.js';

import(module).then(file => { console.log(file);});
```

在一个模块中，如果同时导出了命名成员又导出了默认成员，在导入的时候可以同时导入。

```js
// 导出
export { name };
export default title;

// 导入
import title, { name } from './module.js';

// 导入的时候导出
export { foo, bar } from './module.js';
```

默认模块直接导出

```js
export { default as button } from './module.js';
```

### 4. ES Module在浏览器中使用

```ES Module```在```2014```年提出，```IE```完全不支持这个属性。可以使用```polyfill```解决该问题。

```Browser ES Module Loader```这个模块就是个```js```文件，将```polyfill```代码引入，注意一共两个文件，都要引入。

```html
<script nomodule src="https://unpkg.com/promise-polyfill"></script>
```

使用```polyfill```会导致支持的浏览器执行两次模块代码，所以需要在```script```标签中加入```nomodule```标识只有不支持```module```的浏览器才执行该```polyfill```。```module```不建议加入到生产环境使用，因为异步加载太慢了，会影响整个系统的性能。最好的方式还是利用```webpack```等打包工具进行编译阶段打包，在使用阶段直接执行。

### 5. Node 对 ES Module的支持

可以通过```@babel/node```、```@bable/core```、```@babel/preset-env```这三个模块在低版本```Node```中使用```ES Module```。

```preset-env```是一组插件集，可以安装他支持的所有特性，也可以单独安装具体特性单独使用，比如```@babel/plugin-transform-modules-commonjs```

```Node```的最新版本中重新支持了```ES Module```，之前可以通过后缀名```.mjs```和```.cjs```来标识当前模块采用哪种规范来执行(```ES Module```和```CommonJS```)。```12.10.0```之后，可以在```package.json```中添加```type=module```字段，表示所有```js```文件都是```ES Module```，不需要修改后缀名为```.mjs```，但如果想要使用```CommonJS```规范仍需要修改后缀名为```.cjs```。```.mjs```->```ES Module```，```.cjs```->```CommonJS```。

```js
import { foo, bar } from './module.mjs';
console.log(foo, bar);
```

### 6. ES Module和CommonJS的差异

```require```、```module, exports```、```__filename```、```__dirname```这些```CommonJS```的特性在```ES Module```中是不存在的，所以不能使用。

```require```和```export```可以使用```import```和```export```代替。

```__filename```可以使用```import.meta.url```代替。

```__dirname```可以在```__filename```中获取

```js
import {fileURLToPath } from 'url';
import { dirname } from 'path';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

### 7. ES Module载入CommonJS模块

```ES Module```可以载入```CommonJS```模块提供的成员，并且只能载入默认成员，不支持```import {} from```这样提取```CommonJS```。

```CommonJS```无法导入```ES Module```模块，因为```ES Module```只能通过```import```载入。不能通过```require```载入。

```Node```在```8.5```之后，已经支持了```ES Module```，所以在```Node```中已经可以使用```ES Module```了，只是开发者习惯了```Node```的```CommonJS```标准，并且这个标准也没什么问题。

```js
import fs from 'fs';
fs.writeFileSync('./foo.txt', 'es module working');
```
