## 1. 概述

广义上讲，数据结构是指一组数据的存储结构。算法就是操作数据的一组方法。 比如图书馆储藏书籍，为了方便查找，管理员一般会将书籍分类。按照一定规律编号，这就是就是书籍这种“数据”的存储结构。

如何来查找一本书呢?有很多种办法，可以一本一本地找，也可以先根据书籍类别的编号来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。

数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。

## 2. 复杂度

数据结构和算法本身解决的是```快```和```省```的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。

测试环境中硬件的不同会对测试结果有很大的影响。比如同样一段代码，分别用```Intel Core i9```处理器和```Intel Core i3```处 理器来运行，不用说，```i9```处理器要比```i3```处理器执行的速度快很多。还有，比如原本在这台机器上```a```代码执行的速度比```b```代码要快，等换到另一台机器上时，可能会有截然相反的结果。

对同一个排序算法，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。

算法的执行效率粗略地讲就是算法代码执行的时间。但是如何在不运行代码的情况下，用肉眼得到一段代码的执行时间，比如这里有段非常简单的代码，求```1，2，3...n```的累加和。

```js
function cal(n) {
  var sum = 0;
  var i = 1;
  for (; i <= n; i++) {
    sum = sum + i;
  }
  return sum; 
}
```

从```CPU```的⻆度来看，这段代码的每一行都执行着类似的操作，读数据-运算-写数据。尽管每行代码对应的```CPU```执行的个数、执行的时间都不一样，但是这里只是粗略估计，所以可以假设每行代码执行的时间都一样为```unit_time```。

第``2、3``行代码分别需要``1``个```unit_time```的执行时间，第```4、5```行都运行了```n```遍，所以需要```2n * unit_time```的执行时间，所以这段代码总 的执行时间就是```(2n + 2) * unit_time```。可以看出来，所有代码的执行时间```T(n)```与每行代码的执行次数成正比。

尽管不知道```unit_time```的具体值，但是通过这段代码执行时间的推导过程，可以得到一个非常重要的规律，所有代码的执行时间```T(n)```与每行代码的执行次数```n```成正比。

```js
T(n) = O(f(n))
```

```T(n)```表示代码执行的时间，```n```表示数据规模的大小，```f(n)```表示每行代码执行的次数总和。因为这是一个公式，所以用```f(n)```来表示。公式中的```O```，表示代码的执行时间```T(n)```与```f(n)```表达式成正比。

所以，例子中的```T(n) = O(2n + 2)```，就是大```O```时间复杂度表示法。大```O```时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增⻓的变化趋势，所以也叫作渐进时间复杂度(```asymptotic time complexity```)简称时间复杂度。

当```n```很大时公式中的低阶、常量、系数三部分并不左右增⻓趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如果用大```O```表示法表示刚讲的那两段代码的时间复杂度，就可以记为```T(n) = O(n)```。

大```O```这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。总复杂度等于量级最大的那段代码的复杂度。嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

```js
function cal(n) {
  var ret = 0;
  var i = 1;
  for (; i < n; i++) {
     ret = ret + f(i);
   }
}
function f(n) {
  var sum = 0;
  var i = 1;
  for (; i < n; i++) {
    sum = sum + i; 
  }
  return sum; 
}
```

单独看```cal()```函数。假设```f()```只是一个普通的操作，那第```4~6```行的时间复杂度就是，```T1(n) = O(n)```。但```f()```函数本身不是一个简单的操作，它的时间复杂度是```T2(n) = O(n)```，所以，整个```cal()```函数的时间复杂度就是```T(n) = T1(n) * T2(n) = O(n*n) = O(n2)```。


多项式量级: ```O(1)```，```O(logn)```，```O(nlogn)```，```O(m + n)```，```O(m * n)```。

非多项式量级: ```O(2n)```，```O(n!)```。

当数据规模```n```越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增⻓。所以，非多项式时间 复杂度的算法其实是非常低效的算法。

### 1. O(1)

```O(1)```是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有3行，它的时间复杂度也是```O(1)```，而不是```O(3)```。

```js
var i = 8;
var j = 6;
var sum = i + j;
```

### 2. O(logn)

对数阶时间复杂度非常常⻅，同时也是最难分析的一种时间复杂度。

```js
i = 1;
while( i <= n) {
  i = i * 2;
}
```

变量```i```的值从```1```开始取，每循环一次就乘以```2```。当大于```n```时，循环结束。实际上，变量```i```的取值就是一个等比数列。只要知道```x```值是多少，就知道这行代码执行的次数了。```x = log2n```，所以，这段代码的时间复杂度就是```O(log2n)```。

```js
i = 1;
while(i <= n) {
  i = i * 3;
}
```

实际上，不管是以``2``为底、以```3```为底，还是以```10```为底，可以把所有对数阶的时间复杂度都记为```O(logn)```。对数之间是可以互相转换的，```log3n```就等于```log32 * log2n```，所以```O(log3n) = O(C * log2n)```，其中```C = log32```是一个常量。 基于我们前面的一个理论，在采用大```O```标记复杂度的时候，可以忽略系数，即```O(Cf(n)) = O(f(n))```。所以，```O(log2n)```就等于```O(log3n)```。因此，在对数阶时间复杂度的表示方法里，忽略对数的```底```，统一表示为```O(logn)```。

### 3. O(nlogn)

如果一段代码的时间复杂度 是```O(logn)```，循环执行```n```遍，时间复杂度就是```O(nlogn)```了。而且，```O(nlogn)```也是一种非常常⻅的算法时间复杂度。比如归并排序、快速排序的时间复杂度都是```O(nlogn)```。

### 4. O(m+n)、O(m*n)

```js
function cal(m, n) { 
  var sum_1 = 0;
  var i = 1;
  for (; i < m; i++) {
    sum_1 = sum_1 + i;
  }
  var sum_2 = 0;
  var j = 1;
  for (; j < n; j++) {
    sum_2 = sum_2 + j;
  }
  return sum_1 + sum_2;
}
```

```m```和```n```是表示两个数据规模，无法事先评估谁的量级大，所以在表示复杂度的时候，就不能简单省略掉其中一个。所以，上面代码的时间复杂度就是```O(m + n)```。

## 4. 空间复杂的

空间复杂度全称就是渐进空间复杂度(```asymptotic space complexity```)，表示算法的存储空间与数据规模之间的增⻓关系。

```js
function print(n) {
  int i = 0;
  var a = new Array(n); 
  for (i; i < n; i++) {
    a[i] = i * i; 
  }
  for (i = n - 1; i >= 0; i--) { 
    console.log(a[i]);
  } 
}
```

跟时间复杂度分析一样，第```2```行代码中申请了一个空间存储变量```i```，但是它是常量阶的，跟数据规模```n```没有关系，所以可以忽略。第```3```行申请了一个大小为```n```的数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是```O(n)```。

常⻅的空间复杂度就是```O(1)```、```O(n)```、```O(n2)```，像```O(logn)```、```O(nlogn)```这样的对数阶复杂度平时都用不到。而且空间复杂度分析比时间复杂度分析要简单很多。

常⻅的复杂度并不多，从低阶到高阶有```O(1)```、```O(logn)```、```O(n)```、```O(nlogn)```、```O(n2)```。

最好情况时间复杂度是在最理想的情况下，执行这段代码的时间复杂度，最坏情况时间复杂度就是在最糟糕的情况下，执行这段代码的时间复杂度。

比如下面这段代码，复杂度是可能是```O(1)```也可能是```O(n)```就是最好和最坏。

```js
// n表示数组array的⻓度
function find(array, n, x) {
  var i = 0;
  var pos = -1;
  for (; i < n; i++) {
    if (array[i] == x) {
      pos = i;
      break;
    }
  }
  return pos; 
}
```

最好和最坏对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，需要引入平均情况时间复杂度。

要查找的变量```x```在数组中的位置，有```n + 1```种情况，在数组的```0 ~ n-1```位置中和不在数组中。把每种情况下，查找需要遍历的元素个数累加起来，然后再除以```n + 1```，就可以得到需要遍历的元素个数的平均值。

要查找的变量```x```，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便理解，假设在数组中与不在数组中的概率都为```1 / 2```。另外，要查找的数据出现在```0 ~ n - 1```这```n```个位置的概率也是一样的，为```1 / n```。所以，根据概率乘法法则，要查找的数据出现在```0 ~ n - 1```中任意位置的概率就是```1 / (2n)```。

```js
1 * 1 / 2n + 2 * 1 / 2n + 3 * 1 / 2n + 4 * 1 / 2n + ... + n * 1 / 2n = (3n + 1) / 4
```

这个值就是概率论中的加权平均值，也叫作期望值，用大```O```表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度是```O(n)```。

在大多数情况下，并不需要区分最好、最 坏、平均情况时间复杂度三种情况。使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。

均摊时间复杂度，听起来跟平均时间复杂度有点像，这两个概念确实非常容易弄混。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。

```js
// array表示一个⻓度为n的数组 
// 代码中的array.length就等于n 
var array = new Array(n); 
var count = 0;
function insert(val) {
  if (count === array.length) {
    int sum = 0;
    for (int i = 0; i < array.length; i++) {
      sum = sum + array[i];
    }
    array[0] = sum;
    count = 1; 
  }
  array[count] = val;
  count++; 
}
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的```count == array.length```时，用```for```循环遍历数组求和，并清空数组，将求和之后的```sum```值放到数组的第一个位置，然后再将新的数据 插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。

假设数组的⻓度是```n```，根据数据插入的位置的不同，我们可以分为n种情况，每种情况的时间复杂度是```O(1)```。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是```O(n)```。而且```n + 1```种情况发生的概率一样都是```1 / (n + 1)```。根据加权平均的计算方法求得的平均时间复杂度就是```O(1)```。

这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。先来对比一下这个```insert()```的例子和前面那个```find()```的例子，就会发现这两者有很大差别。

首先```find()```函数在极端情况下，复杂度才为```O(1)```。但```insert()```在大部分情况下，时间复杂度都为```O(1)```。只有个别情况下，复杂度才比较高为```O(n)```。这是```insert()```第一个区别于```find()的```地方。

对于```insert()```函数来说```O(1)```时间复杂度的插入和```O(n)```时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个```O(n)```插入之后，紧跟着```n - 1```个```O(1)```的插入操作，循环往复。
所以，针对这样一种特殊场景的复杂度分析，并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。

针对这种特殊的场景，引入了一种更加简单的分析方法: 均摊时间复杂度。

每一次```O(n)```的插入操作，都会跟着```n - 1```次```O(1)```的插入操作，所以把耗时多的那次操作均摊到接下来的```n - 1```次耗时少的操作上，均摊下来这一组连续的操作的均摊时间复杂度就是```O(1)```。这就是均摊分析的大致思路。

均摊时间复杂度和摊还分析应用场景比较特殊，所以并不会经常用到。

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

## 5. 数组

数组(```Array```)是一种线性表数据结构。用一组连续的内存空间来存储一组具有相同类型的数据。

线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。与它相对立的是非线性表，比如二叉树、堆、图等。在非线性表中，数据之间并不是简单的前后关系。

第二个是连续的内存空间和相同类型的数据。正是因为这两个限制，它才可以随机访问。当然这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

拿一个⻓度为```10```的```int```类型数组来举例。计算机给数组分配了一块连续内 空间为1000~1039，其中内存块的首地址为```base_address = 1000```。

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会通过下面的寻址公式计算出该元素存储的内存地址。其中```data_type_size```表示数组中每个元素的大小。

```s
a[i]_address = base_address + i * data_type_size
```

数组是适合查找操作，但是查找的时间复杂度并不为```O(1)```。即便是排好序的数组，用二分查找，时间复杂度也是```O(logn)```。数组支持随机访问，根据下标随机访问的时间复杂度为```O(1)```。

数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，为了避免大规模的数据搬移，还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。

跟插入数据类似，如果要删除第```k```个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了，如果删除数组末尾的数据，则最好情况时间复杂度为```O(1)```，如果删除开头的数据，则最坏情况时间复杂度为```O(n)```，平均情况时间复杂度也为```O(n)```。

实际上，在某些特殊场景下，并不一定非得追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率是不是会提高很多。可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。这就是JVM标记清除垃圾回收算法的核心思想。

## 6. 链表

相比数组，链表是一种稍微复杂一点的数据结构。

数组需要一块连续的内存空间来存储，对内存的要求比较高。如果申请一个```100MB```大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于```100MB```仍然会申请失败。

链表恰恰相反，并不需要连续的内存空间，它通过指针将一组零散的内存块串联起来使用，所以如果申请的是```100MB```大小的链表，根本不会有问题。

```js
// 节点类
class LinkedNode {
  constructor (value) {
    this.value = value
    // 用于存储下一个节点的引用
    this.next = null
  }
}

// 链表类
class LinkedList {
  constructor () {
    this.count = 0
    this.head = null
  }
  // 添加节点 (尾）
  addAtTail (value) {
    // 创建新节点
    const node = new LinkedNode(value)
    // 检测链表是否存在数据
    if (this.count === 0) {
      this.head = node
    } else {
      // 找到链表尾部节点，将最后一个节点的 next 设置为 node
      let cur = this.head
      while (cur.next != null) {
        cur = cur.next
      }
      cur.next = node
    }
    this.count++
  }
  // 添加节点（首）
  addAtHead (value) {
    const node = new LinkedNode(value)
    if (this.count === 0) {
      this.head = node
    } else {
      // 将 node 添加到 head 的前面
      node.next = this.head
      this.head = node
    }
    this.count++
  }
  // 获取节点（根据索引）
  get (index) {
    if (this.count === 0 || index < 0 || index >= this.count) {
      return
    }
    // 迭代链表，找到对应节点
    let current = this.head
    for (let i = 0; i < index; i++) {
      current = current.next
    }
    return current
  }
  // 添加节点（根据索引）
  addAtIndex (value， index) {
    if (this.count === 0 || index >= this.count) {
      return
    }
    // 如果 index <= 0，都添加到头部即可
    if (index <= 0) {
      return this.addAtHead(value)
    }
    // 后面为正常区间处理
    const prev = this.get(index - 1)
    const next = prev.next

    const node = new LinkedNode(value)
    prev.next = node
    node.next = next

    this.count++
  }
  // 删除（根据索引）
  removeAtIndex (index) {
    if (this.count === 0 || index < 0 || index >= this.count) {
      return
    }
    if (index === 0) {
      this.head = this.head.next
    } else {
      const prev = this.get(index - 1)
      prev.next = prev.next.next
    }
    this.count--
  }
}

// 测试代码
const l = new LinkedList()
l.addAtTail('a')
l.addAtTail('b')
l.addAtTail('c')
```

### 1. 单链表

链表通过指针将一组零散的内存块串联在一起。其中把内存块称为链表的结点。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。把这个记录下个结点地址的指针叫作后继指针```next```。

把第一个结点叫作头结点，把最后一个结点叫作尾结点。头结点用来记录链表的基地址。有了它就可以遍历得到整条链表。尾结点特殊的地方是指针指向一个空地址```NULL```，表示这是链表上最后一个节点。

与数组一样，链表也支持数据的查找、插入和删除操作。在链表中插入或者删除一个数据，并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以在链表中插入和删除一个数据是非常快速的。

但是链表要想随机访问第```k```个元素，就没有数组那么高效了，无法像数组那样根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。

可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以希望知道排在第k位的人是谁的时候，需要从第一个人开始，一个一个地往下数。当然删除之前是需要找到对应元素的，也就是需要查询，所以对于删除整体来说复杂度仍然是O(n).

### 2. 循环链表

循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址，循环链表的尾结点指针是指向链表的头结点。

和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。

### 3. 双向链表

单向链表只有一个方向，结点只有一个后继指针```next```指向后面的结点。双向链表支持两个方向，还有一个前驱指针```prev```指向前面的结点。

双向链表需要额外的一个空间来存储前驱结点的地址。如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。

结构上来看双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

对于删除结点，不管是单链表还是双向链表，都需要从头结点开始一个一个依次遍历对比，再通过前面讲的指针操作将其删除。

尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点时间复杂度为O(n)。

如果希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。

对于一个有序链表，双向链表的按值查询的效率比单链表高一些。因为可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

实际上这是用空间换时间的设计思想。当内存空间充足的时候，如果更加追求代码的执行速度，可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

如果把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，比较慢。如果通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。

### 4. 数组和链表

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，访问效率更高。链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。

CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义，这是为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足(out of memory)”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷⻉进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，这也是它与数组最大的区别。

除此之外，如果代码对内存的使用非常苛刻，那数组就更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，导致频繁的GC(Garbage Collection，垃圾回收)。

### 5. 指针

看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。要想写对链表代码，首先就要理解好指针。

有些语言有“指针”的概念，比如C语言，有些语言没有指针，取而代之的是“引用”，比如Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。

哨兵解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。如果引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。把这种有哨兵结点的链表叫带头链表。相反没有哨兵结点的链表就叫作不带头链表。

利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

软件开发中，代码在一些边界或者异常情况下，最容易产生Bug。链表代码也不例外。要实现没有Bug的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。

## 7. 栈

“栈”就像是一摞叠在一起的盘子。总是从下往上一个一个放，取的时候，从上往下一个一个地依次取，不能从中间任意抽出。后进者先出，先进者后出。

从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。从功能上来说，数组或链表确实可以替代栈，但特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，使用时就比较不可控，自然也就更容易出错。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，应该首选“栈”这种数据结构。

栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。 

不管是顺序栈还是链式栈，存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。注意，存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为，这n个空间是必须的，无法省掉。所以说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。

不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是O(1)。

栈作为一个比较基础的数据结构，应用场景还是蛮 多的。其中，比较经典的一个应用场景就是函数调用栈。操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。

```js
class Stack {
  constructor () {
    // 存储栈的数据
    this.data = {}
    // 记录栈的数据个数（相当于数组的 length）
    this.count = 0
  }
  // push() 入栈方法
  push (item) {
    // 方式1：数组方法 push 添加，但并不好，额外引入了数组的属性
    // this.data.push(item)
    // 方式2：利用数组长度，性能比push好，但也是数组的能力
    // this.data[this.data.length] = item
    // 方式3：计数方式
    this.data[this.count] = item
    // 入栈后，count 自增
    this.count++
  }
  // pop() 出栈方法
  pop () {
    // 出栈的前提是栈中存在元素，应先行检测
    if (this.isEmpty()) {
      console.log('栈为空！')
      return
    }
    // 移除栈顶数据
    // 方式1：数组方法 pop 移除
    // return this.data.pop()
    // 方式2：计数方式
    const temp = this.data[this.count - 1]
    delete this.data[--this.count]
    return temp
  }
  // isEmpty() 检测栈是否为空
  isEmpty () {
    return this.count === 0
  }
  // top() 用于获取栈顶值
  top () {
    if (this.isEmpty()) {
      console.log('栈为空！')
      return
    }
    return this.data[this.count - 1]
  }
  // size() 获取元素个数
  size () {
    return this.count
  }
  // clear() 清空栈
  clear () {
    this.data = []
    this.count = 0
  }
}

const s = new Stack()
s.push('a')
s.push('b')
s.push('c')
```

## 8. 队列

队列这个概念非常好理解。可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。

栈只支持两个基本操作：入栈push()和出栈pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。

跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。

```js
class Queue {
  constructor () {
    // 用于存储队列数据
    this.queue = []
    this.count = 0
  }
  // 入队方法
  enQueue (item) {
    this.queue[this.count++] = item
  }
  // 出队方法
  deQueue () {
    if (this.isEmpty()) {
      return
    }
    // 删除 queue 的第一个元素
    // delete this.queue[0]
    // 利用 shift() 移除数组的第一个元素
    this.count--
    return this.queue.shift()
  }
  isEmpty () {
    return this.count === 0
  }
  // 获取队首元素值
  top () {
    if (this.isEmpty()) {
      return
    }
    return this.queue[0]
  }
  size () {
    return this.count
  }
  clear () {
    // this.queue = []
    this.length = 0
    this.count = 0
  }
}

const q = new Queue()
```

对象是可以实现delete删除元素的，这一点要比数组好很多。

```js
class Queue {
  constructor () {
    this.queue = {}
    this.count = 0
    // 用于记录队首的键
    this.head = 0
  }
  // 入队方法
  enQueue (item) {
    this.queue[this.count++] = item
  }
  // 出队方法
  deQueue () {
    if (this.isEmpty()) {
      return
    }
    const headData = this.queue[this.head]
    delete this.queue[this.head]
    this.head++
    this.count--
    return headData
  }
  isEmpty () {
    return this.count === 0
  }
  clear () {
    this.queue = {}
    this.count = 0
    this.head = 0
  }
}

const q = new Queue()
```

随着不停地进行入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。把首尾相连扳成了一个环。

假设队列的大小为8，当前head=4，tail=7。当有一个新的元素a入队时，放入下标为7的位置。这个时候，并不把tail更新为8，而是将其在环中后移一位，到下标为0的位置。当再有一个元素b入队时，将b放入下标为0的位置，然后tail加1更新为1。

队列为空的判断条件仍然是head == tail。但队列满的判断条件就稍微有点复杂了，(tail+1)%n=head。

平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

基于阻塞队列实现的“生产者-消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。

基于阻塞队列还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如可以多配置几个“消费者”，来应对一个“生产者”。

在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

## 8. 树与二叉树

树存在多个节点，每个节点又存在多个节点，树形结构存在层次关系，

树型结构是一种非线性的数据结构，树中的每个部分称为节点，节点间存在分支结构和层次关系。

每个树形结构都具有一个根节点，节点间具有父子兄弟关系。不含子节点的节点称为叶节点。子树是针对某个节点及该节点子孙节点的称呼。

数中最深节点的层级称为树的高度，

二叉树是树形结构中的一种，二叉树中的每个节点最多只能有两个子节点。称为左子节点和右子节点。子节点的树又称为左子树和右子树。

除叶子节点外每个节点都有两个子节点的树称为满二叉树。每层节点都达到最大值。

二叉树除最后一层，每层节点都达到最大值，且最后一层节点都位于左侧，叫做完全二叉树。

由于完全二叉树的结构连续，有迹可循，所以可以采用顺序存储方式。

普通二叉树由于结构不规则，不适合使用顺序存储，为了记录节点间的关系，可使用链式存储方式。每个节点通过value表示值，left，right表示左右子节点。

### 1. 二叉树遍历

根据访问顺序不同存在三种遍历形式，前序遍历，中序遍历，后序遍历。序表示根节点的访问顺序。

前序遍历: 根节点 > 左子树 -> 右子树

中序遍历: 左子树 -> 根节点 -> 右子树

后序遍历: 左子树 -> 右子树 -> 根节点

### 2. 前序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
/* var preorderTraversal = function(root) {
  // 用于存储遍历的结果
  const res = []
  // 设置函数用于进行递归遍历
  const preorder = (root) => {
    // 当前结点为空时，无需进行递归
    if (!root) {
      return
    }
    // 记录根节点值
    res.push(root.val)
    // 前序遍历左子树
    preorder(root.left)
    // 前序遍历右子树
    preorder(root.right)
  }
  preorder(root)
  return res
}; */

const preorderTraversal = function(root) {
  const res = []
  const stk = []
  while (root || stk.length) {
    while (root) {
      // 右子结点入栈
      stk.push(root.right)
      // 记录根节点
      res.push(root.val)
      // 下一步处理左子节点
      root = root.left
    }
    // 左子树处理完毕，将 stk 出栈，处理右子树
    root = stk.pop()
  }
  return res
}
```

### 3. 最大深度

给定一个二叉树，找出其最大深度，二叉树的深度为根节点到最远叶子节点的最长路径上的点数。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) {
    return 0
  }
  return Math.max(maxDepth(root.left)， maxDepth(root.right)) + 1
};
```

### 4. 层序遍历

给定一个二叉树，返回层序遍历的节点值。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  const res = []
  if (!root) {
      return res
  }
  // 声明队列用于存储后续数据
  const q = []
  q.push(root)

  // 遍历队列
  while (q.length !== 0) {
      // 针对本轮操作，创建一个新的二维数组
      res.push([])
      let len = q.length
      for (let i = 0; i < len; i++) {
          // 将本次操作的结点出队
          const node = q.shift()
          res[res.length - 1].push(node.val)
          // 检测是否存在左右子结点，如果有，入队即可
          if (node.left) {
              q.push(node.left)
          }
          if (node.right) {
              q.push(node.right)
          }
      }
  }
  return res
};
```

### 5. 二叉搜索树

是一种特殊的二叉树形式，简称BST，左子树的节点小于根节点，右子树的节点大于根节点。子树也为二叉搜索树。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
/* var isValidBST = function(root) {
  // 通过一个辅助函数来统一设置左右子树的比较
  return helper(root， -Infinity， Infinity);
};

const helper = (root， lower， upper) => {
  if (root === null) {
    return true
  }
	// 当前节点值超出边界，说明二叉树为非 BST
  if (root.val <= lower || root.val >= upper) {
    return false;
  }
  // 否则，递归处理左右子节点，并更新大小范围
  // 同时根据左右子节点的返回值进行返回，只有全部递归结果均为 true， 才说明二叉树为 BST
  return helper(root.left， lower， root.val) && helper(root.right， root.val， upper);
} */

/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  let stk = []
  // 用于记录上一次取得的节点值，BST 中这个值应小于当前节点
  // 设置默认值为 -Infinity 避免对比较结果产生干扰
  let oldNode = -Infinity

  while (root || stk.length) {
    while (root) {
      stk.push(root) 
      root = root.left
    }
    root = stk.pop()
    // 如果任意节点比上个节点值小，说明二叉树不是 BST
    if (root.val <= oldNode) {
      return false
    }
    // 通过比较，记录当前节点值
    oldNode = root.val
    root = root.right
  }
  return true
};
```