base64 是网络上最常见的用于传输```8Bit```字节码的编码方式之一，```base64```就是一种基于```64```个可打印字符来表示二进制数据的方法。

对于前端来说，一切可以放路径的地方，都可以使用```base64```来替代。

```node```中的```buffer```对象可以通过```toString```('base64')将```buffer```对象输出为```base64```。我们这里来简述一下汉字是如何转换成为```base64```的实现原理。

比如我们来探索一下汉子"哈"通过```base64```的转换结果为"5ZOI"是如何实现的。

首先我们利用```nodejs```中```Buffer```对象的```from```方法，将汉子转换为```buffer```对象。可以得到```e5``` ```93``` ```88```三个```16```进制的字节。可以看到这个函子由```3```个字节组成。

```js
const buf = Buffer.from("哈");
console.log(buf); // // e5 93 88
```  

然后再将每个字节转换为二进制，```0x```代表```16```进制，我们需要在```e5``` ```93``` ```88```前面分别拼上```0x```， ```toString```方法中可以传入要转换的字进制，这里写```2```。

```js
// 将每个字节转为二进制
(0xe5).toString(2); // 11100101
(0x93).toString(2); // 10010011
(0x88).toString(2); // 10001000
```

接着将得到的三个```2```进制数据连接在一起，得到```111001011001001110001000```。

```js
111001011001001110001000
```

然后将```111001011001001110001000```每```6```个一组进行切割，这里可以切割为```4```部分。

```js
111001 011001 001110 001000
```

接着在每一组的前面用```0```补位，凑成```8```位。

```js
00111001
00011001
00001110
00001000
```

将得到的四组数据分别再转换为```10```进制数据。这里一共可以获得```4```个数字，是不是"哈"这个字转换为```base64```后获取到的```4```个字符有些接近了。

```js
parseInt('00111001', 2); // 二进制变为10进制 57
parseInt('00011001', 2); // 二进制变为10进制 25
parseInt('00001110', 2); // 二进制变为10进制 14
parseInt('00001000', 2); // 二进制变为10进制 8
```

```base64```的编码数据基本是从```A-Z```加上```a-z```再加上```0123456789+/```中获取的。我们拼接出这个字符串。

```js
// ```base64```编码
let str = 'ABCDEFGHIGKLMNOPQRSTUVWSYZ';
str += str.toLowerCase(); // 小写字符拼接一次
str += '0123456789+/'; // 数字拼接一次
```

我们知道，字符串可以类似数组一样通过下标来获取指定位置的字符，这里通过上面```10```进制转换之后的值分别获取对应位置的字符，```57```获取的就是```5```，```25```获取的就是```Z```，```14```获取的就是```O```，```8```获取的就是```I```。

将这四个字符拼接在一起就是```5ZOI```。就是之前转换后的```base64```。

```js
const ```base64``` = str[57] + str[25] + str[14] + str[8]; // 5ZOI
```

## 2. 转译步骤

1. 将字符串通过Buffer.from获取buffer，并将buffer中的每个16的buffer字节转为2进制

2. 将所有二进制拼接在一起，6个一组进行划分，在前面补00，凑成8位二进制

3. 将新的二进制转换成10进制

4. 在```base64```集合中分别通过10进制下标取出，并链接
